// Copyright (C) 2022-2023 by Camden Mannett.
// Distributed under the Boost Software License, Version 1.0.
// (See accompanying file LICENSE or copy at https://www.boost.org/LICENSE_1_0.txt)

namespace arg_router
{
/** @page help Help
 * @tableofcontents
 *
 * Help output is crucial for most application's command line interface, in arg_router this data is
 * held in help_data::type, which is a simple struct that forms a tree that @em generally mirrors
 * the parse tree.  This data can be generated automatically using the type's policies via
 * help_data::generate(const Node& node, const FilterFn& f).
 *
 * If you want to change the textual help output, you can implement a method in your node type
 * called generate_help_data(const FilterFn& f) const, which returns a help_data::type instance.
 *
 * Unlike most parts of arg_router, help generation is gathered at runtime.
 *
 * @section help_node Help Node
 * The help_data::type tree does not do anything on its own, they are read by the help_t node which
 * at collects and formats the complete output. The help node is an argument-like node (e.g. arg_t),
 * it accepts a chain of mode-like type names through the parse tree to show only the
 * help for that node (see the README.md for examples of this).  To achieve this, in the node's
 * parse method it iteratively searches through the tree's descendents (starting at the root), the
 * last node requested has it's help data shown.
 *
 * The help_t node checks for the presence of a policy::flatten_help_t policy - flattening is
 * determined at compile-time.  'Flattened' help output is where all the child help data is
 * displayed with the parent, rather than only the parent output being displayed and the child
 * help data having to be explicitly requested through the command line.
 *
 * From the node developer's point of view, typically a non-flattened help_data::type would have an\
 * empty children list.
 *
 * @section help_formatter Help Formatting
 * By default help_t will use policy::default_help_formatter_t, which generates basic output as
 * shown by the examples in the README.  The formatter delegates much of the formatting duty to
 * formatter components:
 * - @b LineFormatter @n
 * As the same suggests this controls the printing of the argument output.  It is called once per
 * node.  default_help_formatter_t will use
 * policy::help_formatter_component::default_line_formatter by default.
 * - @b PreambleFormatter @n
 * This controls the printing of the preamble, which typically consists of the program name,
 * version, and introduction text.  These are provided by policy::program_name_t, etc. that are
 * associated with the owning help_t.  default_help_formatter_t will use
 * policy::help_formatter_component::default_preamble_formatter by default.
 * - @b AddendumFormatter @n
 * The controls the printing of the addendum, which text printed @em after the argument
 * documentation.  The text is provided by the policy::program_addendum_t associated with the
 * owning help_t.  default_help_formatter_t will use
 * policy::help_formatter_component::default_addendum_formatter by default.
 *
 * You will notice that there's no API information here, that's because the API is not fixed as the
 * formatter components belong the formatter.  So minor changes can be achieved via writing your
 * own formatter components, whilst more dramatic changes will require a new formatter.
 *
 * The default line formatter (policy::help_formatter_component::default_line_formatter) is quite
 * basic, so a colour version is provided in the library too:
 * policy::help_formatter_component::colour_line_formatter.
 */
}  // namespace arg_router
