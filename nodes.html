<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>arg_router: Nodes</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">arg_router
   &#160;<span id="projectnumber">0.0.1</span>
   </div>
   <div id="projectbrief">C++ command line argument parsing and routing</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Nodes </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#nodes_parameter_organising">Parameter Organising</a></li>
<li class="level1"><a href="#nodes_find">Find</a><ul><li class="level2"><a href="#nodes_match">Match</a></li>
</ul>
</li>
<li class="level1"><a href="#nodes_parse">Parse</a></li>
<li class="level1"><a href="#nodes_process_value_tokens">process_value_tokens(..)</a></li>
</ul>
</div>
<div class="textblock"><p>Types that derive from <a class="el" href="classarg__router_1_1tree__node.html">tree_node</a> form the nodes of the parse tree.</p>
<h1><a class="anchor" id="nodes_parameter_organising"></a>
Parameter Organising</h1>
<p>The first task <a class="el" href="classarg__router_1_1tree__node.html">tree_node</a> has to do is organise the constructor parameters.</p><ul>
<li>Policies are used to derive from, and are therefore used in the inheritance declaration</li>
<li><a class="el" href="classarg__router_1_1tree__node.html">tree_node</a> derived types are children and are moved into an internal tuple to hold them</li>
<li>Anything else causes a <code>static_assert</code> failure</li>
</ul>
<p>Splitting out other <a class="el" href="classarg__router_1_1tree__node.html">tree_node</a> derived types has a further complexity due to <a class="el" href="classarg__router_1_1list.html">list</a>, which will need flattening first.</p>
<h1><a class="anchor" id="nodes_find"></a>
Find</h1>
<p>One of the key pieces of functionality <a class="el" href="classarg__router_1_1tree__node.html">tree_node</a> provides is the ability for it to find a child node using a <a class="el" href="structarg__router_1_1parsing_1_1token__type.html">parsing::token_type</a>. This forms the core of how nodes are matched up against the user's command line tokens.</p>
<p><a class="el" href="classarg__router_1_1tree__node.html#a3d51367f87893bddee652f0895680e1e">tree_node::find</a> uses a generic visitor <code>Callable</code> so that a matching node's type can be accessed by the caller. An optional results tuple can be provided too, this is so mode-like types (e.g. <a class="el" href="classarg__router_1_1mode__t.html">mode_t</a>) can provide the current result of that child node during the search. This is useful for some nodes that need iteratively 'filling' during parsing e.g. <a class="el" href="classarg__router_1_1positional__arg__t.html">positional_arg_t</a> which will match against any token (positional arguments are 'greedy') until it's maximum count is reached (if any, normally provided by <a class="el" href="classarg__router_1_1policy_1_1min__max__count__t.html">policy::min_max_count_t</a>).</p>
<p>The find method works by iterating over the child tuple and calling each node's match method, which takes the queried token and a visitor <code>Callable</code> that accepts a const reference to the child node (e.g <a class="el" href="classarg__router_1_1flag__t.html#ad8dc963d4c304e80d00e55e4fcf0ab82">flag_t::match</a>), and an optional result arg as described above (e.g. <a class="el" href="classarg__router_1_1positional__arg__t.html#a4ada798a13c07c13eb3fe2dbd9414bc4">positional_arg_t::match</a>).</p>
<h2><a class="anchor" id="nodes_match"></a>
Match</h2>
<p>The match method is one of two methods every <a class="el" href="classarg__router_1_1tree__node.html">tree_node</a> derived type must implement in order for compilation to succeed. It just needs to check that the input token_type (and optional result) is correct for the node, call the visitor with itself if it is correct, and return whether or not a match occurred.</p>
<p>You don't need to provide a defaulted result type when implementing, <a class="el" href="classarg__router_1_1tree__node.html#a3d51367f87893bddee652f0895680e1e">tree_node::find</a> detects the arity of the target node's match method and the size of the requests result tuple (defaults to empty) and passes the result type accordingly. In other words only if the requestor provided a results tuple and your node's match method has a third argument, will you be passed a result value.</p>
<p>For most node types the implementation involves checking that the input token_type matches one of the node's names (typically implemented by <a class="el" href="classarg__router_1_1policy_1_1long__name__t.html">policy::long_name_t</a>, <a class="el" href="classarg__router_1_1policy_1_1short__name__t.html">policy::short_name_t</a>, or <a class="el" href="classarg__router_1_1policy_1_1none__name__t.html">policy::none_name_t</a>). As this is a common use case, there is a convenience function that does the checking for you: <a class="el" href="namespacearg__router_1_1parsing.html#a8cd5ccafb2ad5067217c034ecf0c9d0a">parsing::default_match</a>.</p>
<h1><a class="anchor" id="nodes_parse"></a>
Parse</h1>
<p>Every <a class="el" href="classarg__router_1_1tree__node.html">tree_node</a> derived type also needs to provide a parse function, which as the name suggests, processes some tokens from the <a class="el" href="classarg__router_1_1parsing_1_1token__list.html">parsing::token_list</a> in order to produce a value that represents the tokens in some way.</p>
<p>For more detail, let's look at what a typical node like <a class="el" href="classarg__router_1_1arg__t.html">arg_t</a> does:</p><ol type="1">
<li>Check there are at least two tokens still to be processed, one for the arg's name and one for the value</li>
<li>Call <a class="el" href="classarg__router_1_1parsing_1_1token__list.html#a6d6f59a3d781a45611921aea9e2c91a5">parsing::token_list::mark_as_processed</a> to mark the arg name as processed i.e. consume it from token pending list</li>
<li>Call the pre-parse phase methods on the policies that support it</li>
<li>Parse the value token using <a class="el" href="classarg__router_1_1tree__node.html#a2a8f5775af1259c3c3363160456dd94e">tree_node::parse</a></li>
<li>Mark the value token as processed</li>
<li>Call the valdation phase methods on the policies that support it</li>
<li>If there is a routing phase policy, that call it with the parsed result</li>
<li>Return the parsed value to the caller</li>
</ol>
<p>There are two exits for the node, if the node is top-level then once parsing is complete we can exit to the library user's code with it, as it's the only value expected to be parsed from the command line. However, often the node is the child of a mode-like type (e.g. <a class="el" href="classarg__router_1_1mode__t.html">mode_t</a>) which is building up a results tuple from the parsed tokens, in that case we return the value to the mode.</p>
<p>It's important to note that every node needs this method, even if they don't parse a value off the command line e.g. <a class="el" href="classarg__router_1_1flag__t.html">flag_t</a> which does this:</p><ol type="1">
<li>Call <a class="el" href="classarg__router_1_1parsing_1_1token__list.html#a6d6f59a3d781a45611921aea9e2c91a5">parsing::token_list::mark_as_processed</a> to mark the flag name as processed i.e. consume it from token pending list</li>
<li>Call the pre-parse phase methods on the policies that support it</li>
<li>If there is a routing phase policy, that call it with the parsed result</li>
<li>Return the parsed value to the caller</li>
</ol>
<p>In this case the 'parsed result' is an implicit <code>true</code> boolean value as the presence of a flag indicates a positive value.</p>
<h1><a class="anchor" id="nodes_process_value_tokens"></a>
process_value_tokens(..)</h1>
<p>This is an optional static method with the signature: </p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> process_value_tokens(span&lt;const char*&gt;&amp; args, parsing::token_list&amp; result)</div>
</div><!-- fragment --><p> It is used by the input token processing phase if the owning node does <em>not</em> have a policy that implements <code>maximum_count()</code> and this method is present. This phase needs to work out how many 'value' tokens belong to each node so it can categorise them correctly, typically this is provided by a <code>maximum_count()</code>-implementing policy or nothing (i.e. no value tokens), but some nodes (e.g. <a class="el" href="classarg__router_1_1positional__arg__t.html">positional_arg_t</a>) <em>may</em> not have this policy but still consume value tokens - this method provides this functionality. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
