<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>arg_router: Policies</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">arg_router
   </div>
   <div id="projectbrief">C++ command line argument parsing and routing</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Policies </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#policies_basic">Basic Categories</a><ul><li class="level2"><a href="#policies_basic_static_data">Static Data Provider</a></li>
<li class="level2"><a href="#policies_basic_tag_type">Tag Type</a></li>
<li class="level2"><a href="#policies_basic_parsing_phase">Parsing Phase Provider</a><ul><li class="level3"><a href="#policies_basic_parsing_phase_pre">Pre-Parse Phase</a></li>
<li class="level3"><a href="#policies_basic_parsing_phase_parse">Parse Phase</a></li>
<li class="level3"><a href="#policies_basic_parsing_phase_validation">Validation Phase</a></li>
<li class="level3"><a href="#policies_basic_parsing_phase_routing">Routing Phase</a></li>
<li class="level3"><a href="#policies_basic_parsing_phase_missing">Missing Phase</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#policies_defining">Defining a Policy</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="policies_basic"></a>
Basic Categories</h1>
<p>Policies fall into three basic categories, although in principle a policy could fall into more than one.</p>
<h2><a class="anchor" id="policies_basic_static_data"></a>
Static Data Provider</h2>
<p>Many policies just provide some user-set compile-time data to the system using a commonly named method that can be detected at compile-time.</p>
<p><a class="el" href="classarg__router_1_1policy_1_1long__name__t.html">policy::long_name_t</a> is a simple example of this, the user provides a string which is then exposed by the static method <code>long_name()</code>. <code>long_name()</code> is a 'common' method i.e. one that is known by the library so any policy that has that method can be used to provide long names to nodes. Look in the <a class="el" href="namespacearg__router_1_1traits.html">traits</a> namespace for the <code>has_*_method</code> traits types for all the common methods.</p>
<h2><a class="anchor" id="policies_basic_tag_type"></a>
Tag Type</h2>
<p>Some policies are tag types, just their presence indicates that <em>something</em> needs to be done. What that <em>something</em> is depends on the <em>thing</em> doing the detecting.</p>
<p>An example of this is <a class="el" href="structarg__router_1_1policy_1_1no__result__value.html">policy::no_result_value</a>. This is used by <a class="el" href="classarg__router_1_1mode__t.html">mode_t</a> (and others) to detect children whose parsing process does <b>not</b> result in a value that can be passed to the owned <a class="el" href="classarg__router_1_1policy_1_1router.html">policy::router</a>.</p>
<h2><a class="anchor" id="policies_basic_parsing_phase"></a>
Parsing Phase Provider</h2>
<p>Most of the policies do more than the above though, they take an active part in the parsing. Parsing a token is a multi-stage process for most nodes and policies facilitate this by supporting a series of common methods that are detected by nodes at compile-time (see <a class="el" href="namespacearg__router_1_1policy.html">policy</a> namespace's <code>has_*_method</code> traits types).</p>
<p>All policies that provide a phase method where multiple policies held by a node can provide an implementation (i.e. <em>not</em> parse, routing, or missing phases - only one policy can provide those for a node) should hold a <code>priority</code> static member that provides the order policies should be called in (when applicable). The lower the number, the lower the priority. Policies in the library vary from 0 to 1000, where 0 means that the priority is irrelevant. If no priority is specified, 0 is assumed. This allows the user to specify the policies in any order, but they'll always be evaluated in the same order.</p>
<h3><a class="anchor" id="policies_basic_parsing_phase_pre"></a>
Pre-Parse Phase</h3>
<p>As the name suggests this is a phase that performs some kind of input checking or manipulation before parsing occurs. <a class="el" href="classarg__router_1_1policy_1_1alias__t.html">policy::alias_t</a> is a complex example of this, it copies the current token's value (i.e. the alias' value) and then creates new tokens for all the aliased arguments using that value. In other words it creates new tokens and values as if the user had passed them in, ready for a later parsing process to consume.</p>
<p>A simpler example is <a class="el" href="classarg__router_1_1policy_1_1min__max__count__t.html">policy::min_max_count_t</a>, which simply checks that there enough tokens remaining in pending list to satisfy the minimum. This is used by <a class="el" href="classarg__router_1_1positional__arg__t.html">positional_arg_t</a> to validate the input before starting parsing. If you're wondering what does the maximum checking, that's an example of the policy also being a static data provider - it provides the compile-time maximum count to the <a class="el" href="classarg__router_1_1positional__arg__t.html">positional_arg_t</a> node which only consumes up to that amount when pre-parsing.</p>
<h3><a class="anchor" id="policies_basic_parsing_phase_parse"></a>
Parse Phase</h3>
<p>This is the phase that takes the token and converts to it a value type that the user's code can consume. There is only one parsing policy in <a class="el" href="namespacearg__router.html">arg_router</a> and that is <a class="el" href="classarg__router_1_1policy_1_1custom__parser.html">policy::custom_parser</a>, which allows a library user to pass a <code>Callable</code> to their node which delegates the parsing to that.</p>
<p>Typically developers want their parsers to be written for a <em>type</em> rather than a particular node, so unlike the other phases, policies implementing this phase are not called directly - nodes call <a class="el" href="classarg__router_1_1tree__node.html#a2a8f5775af1259c3c3363160456dd94e">tree_node::parse(std::string_view token, const Parents&amp;... parents) const </a>which uses a parse phase policy if one is present, or uses one of the global per-type parsers (<a class="el" href="structarg__router_1_1parser.html">parser</a>). Which is why library users do not need to use a <a class="el" href="classarg__router_1_1policy_1_1custom__parser.html">policy::custom_parser</a> on every node that expects one or more value tokens.</p>
<dl class="section note"><dt>Note</dt><dd>Only one policy used by a <a class="el" href="classarg__router_1_1tree__node.html">tree_node</a> can support a parse phase. It doesn't make any sense to parse more than once.</dd></dl>
<h3><a class="anchor" id="policies_basic_parsing_phase_validation"></a>
Validation Phase</h3>
<p>Once the value has been parsed it can be validated by other policies, <a class="el" href="classarg__router_1_1policy_1_1min__max__value.html">policy::min_max_value</a> being an example. It simply checks that the parsed value is between two values as determined by a comparator (defaulting to <code>std::less</code>), if it fails the check then a <a class="el" href="classarg__router_1_1parse__exception.html">parse_exception</a> is thrown.</p>
<h3><a class="anchor" id="policies_basic_parsing_phase_routing"></a>
Routing Phase</h3>
<p>The final parse phase is the one that performs the routing of the result values back to the library user.</p>
<p>There is only one policy that does this in <a class="el" href="namespacearg__router.html">arg_router</a> and that is <a class="el" href="classarg__router_1_1policy_1_1router.html">policy::router</a>, which takes a user-provided <code>Callable</code> and forwards the parsed values to it <em>after</em> checking that there are no more tokens remaining after parsing (i.e. "unhandled tokens").</p>
<dl class="section note"><dt>Note</dt><dd>Only one policy used by a <a class="el" href="classarg__router_1_1tree__node.html">tree_node</a> can support a routing phase. The library must only exit to the library user's code once when parsing is complete.</dd></dl>
<h3><a class="anchor" id="policies_basic_parsing_phase_missing"></a>
Missing Phase</h3>
<p>Although the 'Routing Phase' is the final 'normal' phase, there is another that is performed on child nodes who have not been given a token to parse i.e. the token(s) they represent are not present on the command line.</p>
<p>The two standard policies that implement this phase are <a class="el" href="classarg__router_1_1policy_1_1default__value.html">policy::default_value</a> and <a class="el" href="classarg__router_1_1policy_1_1required__t.html">policy::required_t</a>. They either return a user-defined default value or throw an exception respectively.</p>
<dl class="section note"><dt>Note</dt><dd>Only one policy used by a <a class="el" href="classarg__router_1_1tree__node.html">tree_node</a> can support a missing phase.</dd></dl>
<h1><a class="anchor" id="policies_defining"></a>
Defining a Policy</h1>
<p>Because the parse tree nodes derive from (typically) multiple policies so that their methods become available to the public interface of the nodes, policies themselves do not have a base class (the old diamond inheritance problems). So in order to 'mark' a type as a policy so it can be detected as such by <a class="el" href="namespacearg__router.html">arg_router</a>, <a class="el" href="structarg__router_1_1policy_1_1is__policy.html">policy::is_policy</a> needs specialising. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
