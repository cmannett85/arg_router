<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=9" />
    <meta name="generator" content="Doxygen 1.9.1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>arg_router: Architectural Overview</title>
    <link href="tabs.css" rel="stylesheet" type="text/css" />
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
    <!--Doxygen Styling-->
    <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
    <script type="text/javascript">DoxygenAwesomeDarkModeToggle.init()</script>
    <script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
    <script type="text/javascript">DoxygenAwesomeParagraphLink.init()</script>
</head>
<body>
    <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
        <div id="titlearea">
            <table cellspacing="0" cellpadding="0">
                <tbody>
                    <tr style="height: 56px;">
                        <td id="projectalign" style="padding-left: 0.5em;">
                            <div id="projectname">arg_router
                                &#160;<span
                                    id="projectnumber">1.4.0</span>
                            </div>
                            <div id="projectbrief">C++ command line argument parsing and routing</div>
                        </td>
                    </tr>
                </tbody>
            </table>
        </div>
        <!-- end header part --><!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('architecture.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Architectural Overview </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#node_relationships">Node Relationships</a><ul><li class="level2"><a href="#node_relationships_policies">Policies</a></li>
<li class="level2"><a href="#node_relationships_nodes">Nodes</a></li>
<li class="level2"><a href="#node_relationships_validation">Validation</a></li>
</ul>
</li>
<li class="level1"><a href="#node_relationships_parsing">Parsing</a></li>
</ul>
</div>
<div class="textblock"><p>In <a class="el" href="namespacearg__router.html">arg_router</a> core functionality is defined by the parse tree, which consists of <a class="el" href="classarg__router_1_1tree__node.html">tree_node</a> instances that define the parse tree structure (i.e. a parse entry point and token grouping), and policies that define the reusable behaviours of nodes.</p>
<dl class="section note"><dt>Note</dt><dd>In order to reduce ambiguity, the term <em>token</em> is used for referring to words or symbols passed to the command line by the user; which could be long or short form options (e.g. <code>-f</code>, <code>&ndash;flag</code>) or the values for those options. The term <em>argument</em> is used exclusively for a token that expects another word to follow it e.g. <a class="el" href="classarg__router_1_1arg__t.html">arg_t</a>.</dd></dl>
<h1><a class="anchor" id="node_relationships"></a>
Node Relationships</h1>
<div class="image">
<object type="image/svg+xml" data="node_relationships.svg" height="400px" style="pointer-events: none;"></object>
</div>
<h2><a class="anchor" id="node_relationships_policies"></a>
Policies</h2>
<p>Policies are common sets of behaviours which can be re-used between nodes, but more importantly for us, can be used by a library user to 'build' a custom <a class="el" href="classarg__router_1_1tree__node.html">tree_node</a> by assembling a collection of policies.</p>
<p>Policies come in three basic flavours:</p><ul>
<li>A core type, that just provides some static data (e.g. <a class="el" href="classarg__router_1_1policy_1_1long__name__t.html">policy::long_name_t</a>)</li>
<li>A parsing type, that provides one or more methods that are used by the derived node to generate, check, and manipulate the input tokens (e.g. <a class="el" href="classarg__router_1_1policy_1_1min__max__count__t.html">policy::min_max_count_t</a>)</li>
<li>A tag type, that provides no data, just it's own presence which can be detected by other parts of the library</li>
</ul>
<h2><a class="anchor" id="node_relationships_nodes"></a>
Nodes</h2>
<p>Nodes are implemented by deriving from <a class="el" href="classarg__router_1_1tree__node.html">tree_node</a>, passing one or more policies and/or children to it's constructor. Nodes can contain other nodes (i.e. children) and in doing so form a tree structure - our parse tree!</p>
<p>As you may have noticed from the above diagram, <a class="el" href="classarg__router_1_1tree__node.html">tree_node</a> is clever, it can work out which constructor args are policies and which are nodes by itself so you can pass them in any order you like.</p>
<h2><a class="anchor" id="node_relationships_validation"></a>
Validation</h2>
<p>Although the nodes can do a lot of compile-time error checking themselves from analysing their children and policies, they can't check everything - mainly because you can easily get into dependency loops by nodes needing to know about other node types and vice-versa (which also leads to horrible spaghetti code).</p>
<p>To prevent this, <em>inter-node</em> validation is done separately by a special policy called <a class="el" href="classarg__router_1_1policy_1_1validation_1_1validator.html">policy::validation::validator</a> that can only be derived from by the root node (<a class="el" href="classarg__router_1_1root__t.html">root_t</a>). As the root is the last to be instantiated (the leaves are created first), it has all the information needed to check the entire tree, <em>and</em> because nothing depends on the validator it can know about all the other nodes without causing dependency loops.</p>
<h1><a class="anchor" id="node_relationships_parsing"></a>
Parsing</h1>
<pre class="fragment">["my_app" "mode1" "-f" "--arg" "42"]
            |
            V
          ______
         | Root |  -&gt; [{none, "mode1"}, {none, "-f"}, {none, "--arg"}, {none, "42}]
         |______|
</pre><p> Parsing starts at the root node, where initially the tokens from the shell are converted into an array of <a class="el" href="structarg__router_1_1parsing_1_1token__type.html">parsing::token_type</a> instances each with a type of <a class="el" href="namespacearg__router_1_1parsing.html#a6587078e07827bbbbabeae32b3ed2dd3a334c4a4c42fdb79d7ebc3e73b517e6f8" title="Short prefix.">parsing::prefix_type::none</a> because we don't know what they are yet. You're probably thinking "can't it be inferred from the prefix?", sadly not as the type is also context-dependent e.g. you could have an <a class="el" href="classarg__router_1_1arg__t.html">arg_t</a> that expects a string, but if that string just happened to have the same prefix as a flag then the prefix would be stripped at this stage. </p><pre class="fragment">  ______
 | Root |
 |______|     _______
    |-------&gt;| Child | std::optional&lt;parsing::parse_target&gt; pre_parse(
             |_______|      parsing::pre_parse_data&lt;Validator, HasTarget&gt; pre_parse_data,
                            const Parents&amp;... parents) const
</pre><p> The root then iterates through its children calling <code>pre_parse(..)</code> on each until a valid <a class="el" href="classarg__router_1_1parsing_1_1parse__target.html">parsing::parse_target</a> is returned. A <a class="el" href="classarg__router_1_1parsing_1_1parse__target.html">parsing::parse_target</a> is a function object that executes the appropriate node's <code>parse(..)</code> method with the now fully processed <a class="el" href="structarg__router_1_1parsing_1_1token__type.html">parsing::token_type</a> instances.</p>
<p>How a child node decides if it is the correct target and how it processes the tokens is entirely node (and it's policies) dependent. For example an <a class="el" href="classarg__router_1_1arg__t.html">arg_t</a> checks that there are enough unprocessed tokens for the number of value tokens it expects (1 in the case of <a class="el" href="classarg__router_1_1arg__t.html">arg_t</a> via a <a class="el" href="namespacearg__router_1_1policy.html#a41f72699e6e7b4f8f76a8bd4b80ee34c">policy::min_max_count</a>), and then checks that the label token matches the <a class="el" href="classarg__router_1_1arg__t.html">arg_t</a> short or long name. There could be other steps if there are policies that handle the pre-parse phase.</p>
<p>Mode-like types (e.g. <a class="el" href="classarg__router_1_1mode__t.html">mode_t</a>) are complication to this because they need to collect all the valid <a class="el" href="classarg__router_1_1parsing_1_1parse__target.html">parsing::parse_target</a> of their non-mode children - but ultimately follow the same pattern. You'll notice that a mode still follows the same interface for the pre-parse method so how does it return multiple <a class="el" href="classarg__router_1_1parsing_1_1parse__target.html">parsing::parse_target</a> instances? Because you can add sub-targets to it! The top-level target is the mode node itself, and all the subtargets are for the children. </p><pre class="fragment">  ______
 | Root | ------&gt; (*returned_parse_target)()
 |______|
</pre><p> Once the valid <a class="el" href="classarg__router_1_1parsing_1_1parse__target.html">parsing::parse_target</a> is returned to the root, it executes like any other function object. It should be noted that there various scenarios along this path where nodes and policies throw an exception, we'll ignore that here for brevity.</p>
<p>Taking our <a class="el" href="classarg__router_1_1arg__t.html">arg_t</a> example again, the <code>value_type parse(parsing::parse_target target, const Parents&amp;... parents) const</code> method takes the value token and converts it to the expected type. If the node has policies that support the validation phase, then the parsed value is validated by them. If the node has a routing policy attached (only for top-level nodes) then the validated result value is dispatched to it for handling by the library user - otherwise it is returned to the caller (usually for collection by a mode).</p>
<p>As you have probably gathered from the above, the pre-processing and parsing within a node is split up into 'phases' which different policies implement different parts of. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
