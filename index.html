<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=9" />
    <meta name="generator" content="Doxygen 1.9.1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>arg_router: arg_router</title>
    <link href="tabs.css" rel="stylesheet" type="text/css" />
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
    <!--Doxygen Styling-->
    <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
    <script type="text/javascript">DoxygenAwesomeDarkModeToggle.init()</script>
    <script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
    <script type="text/javascript">DoxygenAwesomeParagraphLink.init()</script>
</head>
<body>
    <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
        <div id="titlearea">
            <table cellspacing="0" cellpadding="0">
                <tbody>
                    <tr style="height: 56px;">
                        <td id="projectalign" style="padding-left: 0.5em;">
                            <div id="projectname">arg_router
                                &#160;<span
                                    id="projectnumber">1.2.0</span>
                            </div>
                            <div id="projectbrief">C++ command line argument parsing and routing</div>
                        </td>
                    </tr>
                </tbody>
            </table>
        </div>
        <!-- end header part --><!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title"><a class="el" href="namespacearg__router.html">arg_router</a> </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_docs_README_API"></a><code><a class="el" href="namespacearg__router.html">arg_router</a></code> is a C++17/20 command line parser and router. It uses policy-based objects hierarchically, so the parsing code is self-describing. Rather than just providing a parsing service that returns a map of <code>variant</code>s/<code>any</code>s, it allows you to bind <code>Callable</code> instances to points in the parse structure, so complex command line arguments can directly call functions with the expected arguments - rather than you having to do this yourself.</p>
<h1>Features</h1>
<ul>
<li>Use policies to define the properties and constraints of arguments at compile-time</li>
<li>Group arguments together to define mutually exclusive operating modes, for more complex applications</li>
<li>Define logical connections between arguments</li>
<li>Detects invalid or ambiguous parse trees at compile-time</li>
<li>Generates its help output, which you can modify at runtime using a <code>Callable</code>, or tweak its formatting using policies</li>
<li>Easy custom parsers by using <code>Callable</code>s inline for specific arguments, or you can implement a specialisation to cover all instances of that type</li>
<li>Unicode compliant by supporting UTF-8 encoded compile-time strings (<a href="#unicode-compliance">details</a>)</li>
<li>Support of runtime language selection</li>
<li>Uses a macro to ease compile-time string generation when using C++17. For C++20 and above, compile-time string literals can be used directly in constructors</li>
<li>Available on vcpkg!</li>
</ul>
<h2>Example of the Benefits of a Compile-Time Parse Tree</h2>
<p>It's not immediately obvious why defining a parse tree at compile would bring any benefits, so before we show you <em>how</em> <code><a class="el" href="namespacearg__router.html">arg_router</a></code> is used, let us show you <em>why</em>. Here is a very contrived parse tree defined using the very popular and well-made <a href="https://github.com/p-ranav/argparse">argparse</a>: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;argparse/argparse.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>ap = argparse;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">auto</span> program = ap::ArgumentParser{<span class="stringliteral">&quot;fail!&quot;</span>};</div>
<div class="line">    program.add_argument(<span class="stringliteral">&quot;--verbose&quot;</span>, <span class="stringliteral">&quot;-v&quot;</span>)</div>
<div class="line">        .help(<span class="stringliteral">&quot;Lots of output&quot;</span>)</div>
<div class="line">        .default_value(<span class="keyword">false</span>)</div>
<div class="line">        .implicit_value(<span class="keyword">true</span>);</div>
<div class="line">    program.add_argument(<span class="stringliteral">&quot;--value&quot;</span>, <span class="stringliteral">&quot;-v&quot;</span>)</div>
<div class="line">        .help(<span class="stringliteral">&quot;Do something with a value&quot;</span>)</div>
<div class="line">        .default_value(<span class="keyword">false</span>)</div>
<div class="line">        .implicit_value(<span class="keyword">true</span>);</div>
<div class="line"> </div>
<div class="line">    program.parse_args(argc, argv);</div>
<div class="line">    std::cout &lt;&lt; program.get&lt;<span class="keywordtype">bool</span>&gt;(<span class="stringliteral">&quot;--verbose&quot;</span>) &lt;&lt; <span class="stringliteral">&quot;, &quot;</span></div>
<div class="line">              &lt;&lt; program.get&lt;<span class="keywordtype">bool</span>&gt;(<span class="stringliteral">&quot;--value&quot;</span>) &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> EXIT_SUCCESS;</div>
<div class="line">}</div>
</div><!-- fragment --><p> This parser has an easy to make error, both flags have a short name that is the same, resulting in an ambiguous parse tree. In this example it stands out as the whole program is so small, but it wouldn't be so obvious on a larger, more real-world program. Let's build and run it: </p><div class="fragment"><div class="line">$ ./fail --verbose</div>
<div class="line">1, 0</div>
<div class="line">$ ./fail -v</div>
<div class="line">0, 1</div>
</div><!-- fragment --><p> There is no runtime error detection so you would need to write a test for this scenario. Let's try the equivalent in <code><a class="el" href="namespacearg__router.html">arg_router</a></code>: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;arg_router/arg_router.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>ar = <a class="code" href="namespacearg__router.html">arg_router</a>;</div>
<div class="line"><span class="keyword">namespace </span>arp = ar::policy;</div>
<div class="line"><span class="keyword">using namespace </span>ar::literals;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div>
<div class="line">{</div>
<div class="line">    ar::root(arp::validation::default_validator,</div>
<div class="line">             ar::help(<span class="stringliteral">&quot;help&quot;</span>_S, <span class="stringliteral">&quot;h&quot;</span>_S, arp::program_name_t{<span class="stringliteral">&quot;fail!&quot;</span>_S}),</div>
<div class="line">             ar::mode(ar::flag(<span class="stringliteral">&quot;verbose&quot;</span>_S, <span class="stringliteral">&quot;v&quot;</span>_S, <span class="stringliteral">&quot;Lots of output&quot;</span>_S),</div>
<div class="line">                      ar::flag(<span class="stringliteral">&quot;value&quot;</span>_S, <span class="stringliteral">&quot;v&quot;</span>_S, <span class="stringliteral">&quot;Do something with a value&quot;</span>_S),</div>
<div class="line">                      arp::router{[](<span class="keyword">auto</span> verbose, <span class="keyword">auto</span> value) {</div>
<div class="line">                          std::cout &lt;&lt; verbose &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</div>
<div class="line">                      }}))</div>
<div class="line">        .parse(argc, argv);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> EXIT_SUCCESS;</div>
<div class="line">}</div>
<div class="ttc" id="anamespacearg__router_html"><div class="ttname"><a href="namespacearg__router.html">arg_router</a></div><div class="ttdef"><b>Definition:</b> <a href="algorithm_8hpp_source.html#l00015">algorithm.hpp:16</a></div></div>
</div><!-- fragment --><p> Let's build it: </p><div class="fragment"><div class="line">arg_router/policy/validator.hpp:206:17: error: static_assert failed due to requirement &#39;!std::is_same_v&lt;arg_router::policy::short_name_t&lt;arg_router::utility::str&lt;{{{118, 0}}}&gt;&gt;, arg_router::policy::short_name_t&lt;arg_router::utility::str&lt;{{{118, 0}}}&gt;&gt;&gt;&#39; &quot;Policy must be unique in the parse tree up to the nearest mode or root&quot;</div>
<div class="line">                static_assert(!std::is_same_v&lt;Policy, Current&gt;,</div>
<div class="line">                ^             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div>
</div><!-- fragment --><p> <code>"Policy must be unique in the parse tree up to the nearest mode or root"</code> is a formal way of saying that you've got a duplicate policy, and it's a <code>policy::short_name_t</code>. By having the tree defined at compile-time, it can verify itself via C++ template metaprogramming and cause a build failure. This is a simple example, but there is a great many more checks done during compilation to help you write safer code with less explicit testing.</p>
<h1>Basics</h1>
<p>Let's start simple, with this <code>cat</code>-like program: </p><div class="fragment"><div class="line"><span class="keyword">namespace </span>ar = <a class="code" href="namespacearg__router.html">arg_router</a>;</div>
<div class="line"><span class="keyword">namespace </span>arp = ar::policy</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span>ar::literals;</div>
<div class="line"> </div>
<div class="line">ar::root(</div>
<div class="line">    arp::validation::default_validator,</div>
<div class="line">    ar::help(</div>
<div class="line">        arp::long_name_t{<span class="stringliteral">&quot;help&quot;</span>_S},</div>
<div class="line">        arp::short_name_t{<span class="stringliteral">&quot;h&quot;</span>_S},</div>
<div class="line">        arp::program_name_t{<span class="stringliteral">&quot;my-cat&quot;</span>_S},</div>
<div class="line">        arp::program_version_t{<span class="stringliteral">&quot;v3.14&quot;</span>_S},</div>
<div class="line">        arp::description_t{<span class="stringliteral">&quot;Display this help and exit&quot;</span>_S}),</div>
<div class="line">    ar::flag(</div>
<div class="line">        arp::long_name_t{<span class="stringliteral">&quot;version&quot;</span>},</div>
<div class="line">        arp::description_t{<span class="stringliteral">&quot;Output version information and exit&quot;</span>_S},</div>
<div class="line">        arp::router{[](<span class="keywordtype">bool</span> v) { ... }}),</div>
<div class="line">    ar::mode(</div>
<div class="line">        ar::flag(</div>
<div class="line">            arp::long_name_t{<span class="stringliteral">&quot;show-all&quot;</span>_S},</div>
<div class="line">            arp::description_t{<span class="stringliteral">&quot;Equivalent to -nE&quot;</span>_S},</div>
<div class="line">            arp::short_name_t{<span class="stringliteral">&quot;A&quot;</span>_S},</div>
<div class="line">            arp::alias_t{arp::short_name_t{<span class="stringliteral">&quot;E&quot;</span>_S}, arp::short_name_t{<span class="stringliteral">&quot;n&quot;</span>_S}}),</div>
<div class="line">        ar::flag(</div>
<div class="line">            arp::long_name_t{<span class="stringliteral">&quot;show-ends&quot;</span>_S},</div>
<div class="line">            arp::description_t{<span class="stringliteral">&quot;Display $ at end of each line&quot;</span>_S},</div>
<div class="line">            arp::short_name_t{<span class="stringliteral">&quot;E&quot;</span>_S}),</div>
<div class="line">        ar::flag(</div>
<div class="line">            arp::long_name_t{<span class="stringliteral">&quot;show-nonprinting&quot;</span>_S},</div>
<div class="line">            arp::description_t{<span class="stringliteral">&quot;Use ^ and M- notation, except for LFD and TAB&quot;</span>_S},</div>
<div class="line">            arp::short_name_t{<span class="stringliteral">&quot;n&quot;</span>_S}),</div>
<div class="line">        ar::arg&lt;int&gt;(</div>
<div class="line">            arp::long_name_t{<span class="stringliteral">&quot;max-lines&quot;</span>_S},</div>
<div class="line">            arp::description_t{<span class="stringliteral">&quot;Maximum lines to output&quot;</span>_S},</div>
<div class="line">            arp::value_separator_t{<span class="stringliteral">&quot;=&quot;</span>_S},</div>
<div class="line">            arp::default_value{-1}),</div>
<div class="line">        ar::positional_arg&lt;std::vector&lt;std::string_view&gt;&gt;(</div>
<div class="line">            arp::required,</div>
<div class="line">            arp::min_count&lt;1&gt;,</div>
<div class="line">            arp::display_name_t{<span class="stringliteral">&quot;FILES&quot;</span>_S},</div>
<div class="line">            arp::description_t{<span class="stringliteral">&quot;Files to read&quot;</span>+S}),</div>
<div class="line">        arp::router{[](<span class="keywordtype">bool</span> show_ends,</div>
<div class="line">                       <span class="keywordtype">bool</span> show_non_printing,</div>
<div class="line">                       <span class="keywordtype">int</span> max_lines,</div>
<div class="line">                       std::vector&lt;std::string_view&gt; files) { ... }}))</div>
<div class="line">    .parse(argc, argv);</div>
</div><!-- fragment --><p> Let's start from the top, as the name suggests <code>root</code> is the root of the parse tree and provides the <code>parse(argc, argv)</code> method. Only children of the root can (and must) have a <code>router</code> policy (except for nested <code>mode</code>s, more <a href="#modes">on that later</a>) and therefore act as access points into the program. The root's children are implicitly mutually exclusive, so trying to pass <code>--version --help</code> in the command line is a runtime error.</p>
<p>The <code>arp::validation::default_validator</code> instance provides the default validator that the root uses to validate the parse tree at compile-time. It is a required policy of the <code>root</code>. Unless you have implemented your own policy or tree node you will never need to specify anything else.</p>
<p>The <code>help</code> node is used by the <code>root</code> to generate the argument documentation for the help output, by default it just prints directly to the console and then exits, but a <code>router</code> can be attached that accepts the formatted output to do something else with it. The optional <code>program_name_t</code> and <code>program_version_t</code> policies add a header to the help output.</p>
<p>Now let's introduce some 'policies'. Policies define common behaviours across node types, a basic one is <code>long_name_t</code> which provides long-form argument definition. By default, a standard unix double hyphen prefix for long names is added automatically. Having the name defined at compile-time means we detect duplicate names and fail the build - one less unit test you have to worry about. <code>short_name_t</code> is the single character short-form name, by default a single hyphen is prefixed automatically. <code><a class="el" href="namespacearg__router.html">arg_router</a></code> supports short name collapsing for flags, so if you have defined flags like <code>-a -b -c</code> then <code>-abc</code> will be accepted or <code>-bca</code>, etc. (<b>note</b> short-form name collapsing is disabled if the library has been configured to have the same long and short prefix).</p>
<p>Compile-time strings are created via the <code>""_S</code> string literal, which creates an instance of a <code>ar::str</code> type. <b>Note</b> Advanced NTTP language support that allows for this is not present until C++20, see <a href="#compile-time-string-support">compile-time string support</a> for what to do in C++17.</p>
<p>In order to group arguments under a specific operating mode, you put them under a <code>mode</code> instance. In this case our simple cat program only has one mode, so it is anonymous i.e. there's no long name or description associated with it - it is a build error to have more than one anonymous mode under the root of a parse tree.</p>
<p><code>arg&lt;T&gt;</code> does exactly what you would expect, it defines an argument that expects a value to follow it on the command line. If an argument is not <code>required</code> then it may have a <code>default_value</code> (if neither are set, then a default initialised value is used instead), this is passed to the <code>router</code>'s <code>Callable</code> on parsing if it isn't specified by the user on the command line.</p>
<p>A <code>flag</code> is essentially an <code>arg&lt;bool&gt;{default_value{false}}</code>, except that it doesn't expect an argument value to follow on the command line as it <em>is</em> the value. Flags cannot have default arguments or be marked as required.</p>
<p>An <code>alias</code> policy allows you to define an argument that acts as a link to other arguments, so in our example above passing <code>-A</code> on the command line would actually set the <code>-E</code> and <code>-n</code> flags to true. You can use either the long or short name of the aliased flag, but the <code>value_type</code>s (<code>bool</code> for a flag) must be the same.</p>
<p>By default whitespace is used to separate out the command line tokens, this is done by the terminal/OS invoking the program, but often '=' is used a name/value token separator. <code><a class="el" href="namespacearg__router.html">arg_router</a></code> supports this with the <code>value_separator_t</code> policy as used in the <code>arg&lt;int&gt;</code> node in the example.</p>
<p><code>positional_arg&lt;T&gt;</code> does not use a 'marker' token on the command line for which its value follows, the value's position in the command line arguments determines what it is for. The order that arguments are specified on the command line normally don't matter, but for positional arguments they do; for example in our cat program the files must be specified after the arguments so passing <code>myfile.hpp -n</code> would trigger the parser to land on the <code>positional_arg</code> for <code>myfile.hpp</code> which would then greedily consume the <code>-n</code> causing the application to try to open the file <code>-n</code>... We'll cover constrained <code>positional_arg</code>s in later examples. The <code>display_name_t</code> policy is used when generating help or error output - it is not used when parsing.</p>
<p>Assuming parsing was successful, the final <code>router</code> is called with the parsed argument e.g. if the user passed <code>-E file1 file2</code> then the <code>router</code> is passed <code>(true, false, -1, {"file1", "file2"})</code>.</p>
<p>You may have noticed that the nodes are constructed with parentheses whilst the policies use braces, this is necessary due to CTAD rules that affect nodes which return a user-defined value type. This can be circumvented using a function to return the required instance, for example the actual type of a flag is <code>flag_t</code>, <code>flag(...)</code> is a factory function.</p>
<h2>Implicit String Policies</h2>
<p>Although explicit, which may make it easier to read, the name policies are also verbose. To ease this most of the built-in nodes support implicit string-to-policy mapping, which allows bare compile-time strings to be passed to the node factory functions which are then mapped to appropriate built-in policies. The rules vary from node to node due, but typically they are:</p><ol type="1">
<li>The first multi-character string becomes a <code>policy::long_name_t</code></li>
<li>The second multi-character string becomes a <code>policy::description_t</code></li>
<li>The first single-charcter string becomes a <code>policy::short_name_t</code> The above are unicode aware. The strings can be passed in any order relative to the other policies, but it is recommended to put them first to ease reading.</li>
</ol>
<p>Re-writing the <code>cat</code>-like program using implicit strings shortens it considerably: </p><div class="fragment"><div class="line">ar::root(</div>
<div class="line">    arp::validation::default_validator,</div>
<div class="line">    ar::help(<span class="stringliteral">&quot;help&quot;</span>_S, <span class="stringliteral">&quot;h&quot;</span>_S, <span class="stringliteral">&quot;Display this help and exit&quot;</span>_S,</div>
<div class="line">        arp::program_name_t{<span class="stringliteral">&quot;my-cat&quot;</span>_S},</div>
<div class="line">        arp::program_version_t{<span class="stringliteral">&quot;v3.14&quot;</span>_S}),</div>
<div class="line">    ar::flag(<span class="stringliteral">&quot;version&quot;</span>_S, <span class="stringliteral">&quot;Output version information and exit&quot;</span>_S,</div>
<div class="line">        arp::router{[](<span class="keywordtype">bool</span> v) { ... }}),</div>
<div class="line">    ar::mode(</div>
<div class="line">        ar::flag(<span class="stringliteral">&quot;show-all&quot;</span>_S, <span class="stringliteral">&quot;A&quot;</span>_S, <span class="stringliteral">&quot;Equivalent to -nE&quot;</span>_S,</div>
<div class="line">            arp::alias_t{arp::short_name_t{<span class="stringliteral">&quot;E&quot;</span>_S}, arp::short_name_t{<span class="stringliteral">&quot;n&quot;</span>_S}}),</div>
<div class="line">        ar::flag(<span class="stringliteral">&quot;show-ends&quot;</span>_S, <span class="stringliteral">&quot;E&quot;</span>_S, <span class="stringliteral">&quot;Display $ at end of each line&quot;</span>_S),</div>
<div class="line">        ar::flag(<span class="stringliteral">&quot;show-nonprinting&quot;</span>_S, <span class="stringliteral">&quot;n&quot;</span>_S, <span class="stringliteral">&quot;Use ^ and M- notation, except for LFD and TAB&quot;</span>_S),</div>
<div class="line">        ar::arg&lt;int&gt;(<span class="stringliteral">&quot;max-lines&quot;</span>_S, <span class="stringliteral">&quot;Maximum lines to output&quot;</span>_S,</div>
<div class="line">            arp::value_separator_t{<span class="stringliteral">&quot;=&quot;</span>_S},</div>
<div class="line">            arp::default_value{-1}),</div>
<div class="line">        ar::positional_arg&lt;std::vector&lt;std::string_view&gt;&gt;(<span class="stringliteral">&quot;FILES&quot;</span>_S, <span class="stringliteral">&quot;Files to read&quot;</span>_S,</div>
<div class="line">            arp::required,</div>
<div class="line">            arp::min_count&lt;1&gt;),</div>
<div class="line">        arp::router{[](<span class="keywordtype">bool</span> show_ends,</div>
<div class="line">                       <span class="keywordtype">bool</span> show_non_printing,</div>
<div class="line">                       <span class="keywordtype">int</span> max_lines,</div>
<div class="line">                       std::vector&lt;std::string_view&gt; files) { ... }}))</div>
<div class="line">    .parse(argc, argv);</div>
</div><!-- fragment --><p> This documentation will use implicit string policies going forward, but new nodes will always be introduced with explicit policies.</p>
<h1>Conditional Arguments</h1>
<p>Let's add another feature to our cat program where we can handle lines over a certain length differently. </p><div class="fragment"><div class="line"><span class="keyword">namespace </span>ard = ar::dependency;</div>
<div class="line">ar::mode(</div>
<div class="line">    ...</div>
<div class="line">    ar::arg&lt;std::optional&lt;std::size_t&gt;&gt;(<span class="stringliteral">&quot;max-line-length&quot;</span>_S, <span class="stringliteral">&quot;Maximum line length&quot;</span>_S,</div>
<div class="line">        arp::value_separator_t{<span class="stringliteral">&quot;=&quot;</span>_S},</div>
<div class="line">        arp::default_value{std::optional&lt;std::size_t&gt;{}}),</div>
<div class="line">    ard::one_of(</div>
<div class="line">        arp::default_value{<span class="stringliteral">&quot;...&quot;</span>},</div>
<div class="line">        ar::flag(<span class="stringliteral">&quot;skip-line&quot;</span>_S, <span class="stringliteral">&quot;s&quot;</span>_S, <span class="stringliteral">&quot;Skips line output if max line length reached&quot;</span>_S,</div>
<div class="line">            arp::dependent_t{arp::long_name_t{<span class="stringliteral">&quot;max-line-length&quot;</span>_S}}),</div>
<div class="line">        ar::arg&lt;std::string_view&gt;(<span class="stringliteral">&quot;line-suffix&quot;</span>_S,</div>
<div class="line">            <span class="stringliteral">&quot;Shortens line length to maximum with the given suffix if max line length reached&quot;</span>_S,</div>
<div class="line">            arp::dependent_t{arp::long_name_t{<span class="stringliteral">&quot;max-line-length&quot;</span>_S}},</div>
<div class="line">            arp::value_separator_t{<span class="stringliteral">&quot;=&quot;</span>_S})),</div>
<div class="line">    ...</div>
<div class="line">    arp::router{[](<span class="keywordtype">bool</span> show_all,</div>
<div class="line">                   <span class="keywordtype">bool</span> show_ends,</div>
<div class="line">                   <span class="keywordtype">bool</span> show_non_printing,</div>
<div class="line">                   <span class="keywordtype">int</span> max_lines,</div>
<div class="line">                   std::optional&lt;std::size_t&gt; max_line_length,</div>
<div class="line">                   std::variant&lt;bool, std::string_view&gt; max_line_handling,</div>
<div class="line">                   std::vector&lt;std::string_view&gt;&gt; files) { ... }}))</div>
</div><!-- fragment --><p> We've defined a new argument <code>--max-line-length</code> but rather than using <code>-1</code> as the "no limit" indicator like we did for <code>--max-lines</code>, we specify the argument type to be <code>std::optional&lt;std::size_t&gt;</code> and have the default value be an empty optional - this allows the code to define our intent better.</p>
<p>What do we do with lines that reach the limit if it has been set? In our example we can either skip the line output, or truncate it with a suffix. It doesn't make any sense to allow both of these options, so we declare them under a <code>one_of</code> node. Under this node, only one is valid when parsing at runtime, if the user specifies both then it is an error. A <code>one_of</code> must be marked as required or have a default value in case the user passes none of the arguments it handles.</p>
<p>To express the 'one of' concept better in code, the <code>one_of</code> node has a single representation in the <code>router</code>'s arguments - a variant that encompasses all the value types of each entry in it. In our example's case, a bool for the <code>--skip-line</code> flag and a <code>string_view</code> for the <code>--line-suffix</code> case.</p>
<p>What happens if a user passes <code>--skip-line</code> or <code>--line-suffix</code> without <code>--max-line-length</code>? Normally the developer will have to check that <code>max-line-length</code> is not empty and either ignore or throw if it is. But by specifying the <code>one_of</code> as <code>dependent_t</code> on <code>max-line-length</code>, <code><a class="el" href="namespacearg__router.html">arg_router</a></code> will throw on your behalf in this scenario. To be clear, the <code>dependent_t</code> policy just means that the owner cannot appear on the command line without the <code>arg</code> or <code>flag</code> named in its parameters also appearing on the command line.</p>
<p>The smart developer may have noticed an edge case here. If both the children in the above example had the same <code>value_type</code>, then the variant will be created with multiples of the same type. <code>std::variant</code> supports this but it means that the common type-based visitation pattern will become ambiguous on those identical types i.e. you won't know which flag was used. This may or may not be important to you, but if it is, you will have to <code>switch</code> on <code>std::variant::index()</code> instead.</p>
<h1>Custom Parsing</h1>
<p>Firstly, custom parsing is only needed if the type does not have a constructor that takes a <code>std::string_view</code> (or a type implicitly convertible from it).</p>
<p>Custom parsing for <code>arg</code> and <code>positional_arg</code> types can be done in one of two ways, the first is using a <code>custom_parser</code> policy. Let's add theme coloring to our console output. </p><div class="fragment"><div class="line"><span class="keyword">enum class</span> theme_t {</div>
<div class="line">    NONE,</div>
<div class="line">    CLASSIC,</div>
<div class="line">    SOLARIZED</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">ar::mode(</div>
<div class="line">    ...</div>
<div class="line">    ar::arg&lt;theme_t&gt;(<span class="stringliteral">&quot;theme&quot;</span>_S, <span class="stringliteral">&quot;Set the output colour theme&quot;</span>_S,</div>
<div class="line">        arp::value_separator_t{<span class="stringliteral">&quot;=&quot;</span>_S},</div>
<div class="line">        arp::default_value{theme_t::NONE},</div>
<div class="line">        arp::custom_parser&lt;theme_t&gt;{[](std::string_view <a class="code" href="namespacearg__router.html#a29537daeb3ba7d1b8749d3e1e9d83f1b">arg</a>) {</div>
<div class="line">            <span class="keywordflow">return</span> theme_from_string(arg); }})</div>
<div class="line">    ...</div>
<div class="line">    arp::router{[](<span class="keywordtype">bool</span> show_all,</div>
<div class="line">        <span class="keywordtype">bool</span> show_ends,</div>
<div class="line">        <span class="keywordtype">bool</span> show_non_printing,</div>
<div class="line">        <span class="keywordtype">int</span> max_lines,</div>
<div class="line">        std::optional&lt;std::size_t&gt; max_line_length,</div>
<div class="line">        std::variant&lt;bool, std::string_view&gt; max_line_handling,</div>
<div class="line">        theme_t theme,</div>
<div class="line">        std::vector&lt;std::string_view&gt;&gt; files) { ... }}))</div>
<div class="ttc" id="anamespacearg__router_html_a29537daeb3ba7d1b8749d3e1e9d83f1b"><div class="ttname"><a href="namespacearg__router.html#a29537daeb3ba7d1b8749d3e1e9d83f1b">arg_router::arg</a></div><div class="ttdeci">constexpr auto arg(Policies... policies) noexcept</div><div class="ttdef"><b>Definition:</b> <a href="arg_8hpp_source.html#l00127">arg.hpp:127</a></div></div>
</div><!-- fragment --><p> This is a convenient solution to one-off type parsing in-tree, I think it's pretty self-explanatory. However this is not convenient if you have lots of arguments that should return the same custom type, as you would have to copy and paste the lambda or bind calls to the conversion function for each one. In that case we can specialise on the <code>arg_router::parse</code> function. </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;&gt;</div>
<div class="line"><span class="keyword">struct </span><a class="code" href="structarg__router_1_1parser.html">arg_router::parser</a>&lt;theme_t&gt; {</div>
<div class="line">    [[nodiscard]] <span class="keyword">static</span> <span class="keyword">inline</span> theme_t parse(std::string_view <a class="code" href="namespacearg__router.html#a29537daeb3ba7d1b8749d3e1e9d83f1b">arg</a>)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (<a class="code" href="namespacearg__router.html#a29537daeb3ba7d1b8749d3e1e9d83f1b">arg</a> == <span class="stringliteral">&quot;NONE&quot;</span>) {</div>
<div class="line">            <span class="keywordflow">return</span> theme_t::NONE;</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="namespacearg__router.html#a29537daeb3ba7d1b8749d3e1e9d83f1b">arg</a> == <span class="stringliteral">&quot;CLASSIC&quot;</span>) {</div>
<div class="line">            <span class="keywordflow">return</span> theme_t::CLASSIC;</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="namespacearg__router.html#a29537daeb3ba7d1b8749d3e1e9d83f1b">arg</a> == <span class="stringliteral">&quot;SOLARIZED&quot;</span>) {</div>
<div class="line">            <span class="keywordflow">return</span> theme_t::SOLARIZED;</div>
<div class="line">        }</div>
<div class="line">    </div>
<div class="line">        <span class="keywordflow">throw</span> parse_exception{<span class="stringliteral">&quot;Unknown theme argument: &quot;</span>s + <a class="code" href="namespacearg__router.html#a29537daeb3ba7d1b8749d3e1e9d83f1b">arg</a>};</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="ttc" id="astructarg__router_1_1parser_html"><div class="ttname"><a href="structarg__router_1_1parser.html">arg_router::parser</a></div><div class="ttdef"><b>Definition:</b> <a href="global__parser_8hpp_source.html#l00026">global_parser.hpp:26</a></div></div>
</div><!-- fragment --><p> With this declared in a place visible to the parse tree declaration, <code>theme_t</code> can be converted from a string without the need for a <code>custom_parser</code>. It should be noted that <code>custom_parser</code> can still be used, and will be preferred over the <code>parse()</code> specialisation.</p>
<h1>Counting Flags</h1>
<p>Another Unix feature that is fairly common is flags that are repeatable i.e. you can declare it multiple times on the command line and it's value will increase with each repeat. A classic example of this is 'verbosity levels' for program output: </p><div class="fragment"><div class="line"><span class="keyword">enum class</span> verbosity_level_t {</div>
<div class="line">    ERROR,</div>
<div class="line">    WARNING,</div>
<div class="line">    INFO,</div>
<div class="line">    DEBUG</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">ar::mode(</div>
<div class="line">    ...</div>
<div class="line">    ar::counting_flag&lt;verbosity_level_t&gt;(<span class="stringliteral">&quot;v&quot;</span>_S,</div>
<div class="line">        arp::max_value&lt;verbosity_level_t::DEBUG&gt;(),</div>
<div class="line">        arp::description_t{<span class="stringliteral">&quot;Verbosity level, number of &#39;v&#39;s sets level&quot;</span>_S},</div>
<div class="line">        arp::default_value{verbosity_level_t::ERROR}),</div>
<div class="line">    ...</div>
<div class="line">    arp::router{[](<span class="keywordtype">bool</span> show_all,</div>
<div class="line">        <span class="keywordtype">bool</span> show_ends,</div>
<div class="line">        <span class="keywordtype">bool</span> show_non_printing,</div>
<div class="line">        <span class="keywordtype">int</span> max_lines,</div>
<div class="line">        std::optional&lt;std::size_t&gt; max_line_length,</div>
<div class="line">        std::variant&lt;bool, std::string_view&gt; max_line_handling,</div>
<div class="line">        theme_t theme,</div>
<div class="line">        verbosity_level_t verbosity_level,</div>
<div class="line">        std::vector&lt;std::string_view&gt;&gt; files) { ... }}))</div>
</div><!-- fragment --><p> The number of times <code>-v</code> appears in the command line will increment the returned value, e.g. <code>-vv</code> will result in <code>verbosity_level_t::INFO</code>.</p>
<p>Note that even though we are using a custom enum, we haven't specified a <code>custom_parser</code>. <code>counting_flag</code> will count up in <code>std::size_t</code> and then <code>static_cast</code> to the user-specified type, so as long as your requested type is explicitly convertible to/from <code>std::size_t</code> it will just work. If it isn't, then you'll have to modify your type or not use counting arguments, as attaching a <code>custom_parser</code> to any kind of flag will result in a build failure.</p>
<p>Short name collapsing still works as expected, so passing <code>-Evnv</code> will result in <code>show_ends</code> and <code>show_non_printing</code> being true, and <code>verbosity_level</code> will be <code>verbosity_level_t::INFO</code> in the <code>router</code> call.</p>
<p>We can constrain the amount of flags the user can provide by using the <code>max_value</code> policy, so passing <code>-vvvv</code> will result in a runtime error. There are min/max and min variants too. Here we are using the compile-time variant of the policy, we can do that because the value type is an integral/enum, but if your value type cannot be used as a template parameter then there equivalent runtime variants that take the paramters as function parameters instead. The compile-time variants should be used when possible due to extra checks e.g. setting the max value less than the min.</p>
<p>The <code>long_name_t</code> policy is allowed but usually leads to ugly invocations, however there is a better option: </p><div class="fragment"><div class="line">ar::mode(</div>
<div class="line">    ...</div>
<div class="line">    ard::alias_group(</div>
<div class="line">        arp::default_value{verbosity_level_t::INFO},</div>
<div class="line">        arp::max_value&lt;verbosity_level_t::DEBUG&gt;(),</div>
<div class="line">        ar::counting_flag&lt;verbosity_level_t&gt;(<span class="stringliteral">&quot;v&quot;</span>_S,</div>
<div class="line">            arp::description_t{<span class="stringliteral">&quot;Verbosity level, number of &#39;v&#39;s sets level&quot;</span>_S}),</div>
<div class="line">        ar::arg&lt;verbosity_level_t&gt;(<span class="stringliteral">&quot;verbose&quot;</span>_S, <span class="stringliteral">&quot;Verbosity level&quot;</span>_S,</div>
<div class="line">            arp::value_separator_t{<span class="stringliteral">&quot;=&quot;</span>_S})),</div>
<div class="line">    ...</div>
<div class="line">    arp::router{[](<span class="keywordtype">bool</span> show_all,</div>
<div class="line">        <span class="keywordtype">bool</span> show_ends,</div>
<div class="line">        <span class="keywordtype">bool</span> show_non_printing,</div>
<div class="line">        <span class="keywordtype">int</span> max_lines,</div>
<div class="line">        std::optional&lt;std::size_t&gt; max_line_length,</div>
<div class="line">        std::variant&lt;bool, std::string_view&gt; max_line_handling,</div>
<div class="line">        theme_t theme,</div>
<div class="line">        verbosity_level_t verbosity_level,</div>
<div class="line">        std::vector&lt;std::string_view&gt;&gt; files) { ... }}))</div>
<div class="line">    ...</div>
<div class="line">    </div>
<div class="line"><span class="keyword">template</span> &lt;&gt;</div>
<div class="line"><span class="keyword">struct </span><a class="code" href="structarg__router_1_1parser.html">arg_router::parser</a>&lt;verbosity_level_t&gt; {</div>
<div class="line">    [[nodiscard]] <span class="keyword">static</span> <span class="keyword">inline</span> verbosity_level_t parse(std::string_view <a class="code" href="namespacearg__router.html#a29537daeb3ba7d1b8749d3e1e9d83f1b">arg</a>)</div>
<div class="line">    {</div>
<div class="line">        ...</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p> We can declare a new <code>arg</code> that takes a string equivalent of the enum and put them both into an <code>alias_group</code>, so now you can use <code>--verbose=INFO</code> or <code>-vv</code>. Short name collapsing still works as expected.</p>
<p>What's this new <code>alias_group</code>? <code>policy::alias</code> is an <em>input</em> alias, it works by duplicating the value tokens to each of the aliased nodes it refers to i.e. it forms a one-to-many aliasing relationship. The limitations of that are:</p><ul>
<li>All aliased nodes must have the same value token count (could be zero in the case of a flag)</li>
<li>All aliased nodes must be able to parse the same token formats</li>
</ul>
<p><code>alias_group</code> is almost the opposite of <code>policy::alias</code>, it is an <em>output</em> alias. Each of its child nodes are aliases of the same output value i.e. it forms a many-to-one aliasing relationship. You can also think of <code>alias_group</code> as a variation on <code>one_of</code>, but instead of the output being a <code>std::variant</code> of all the child node output types, <code>alias_group</code> requires that they all have the <em>same</em> output type.</p>
<h1>Constrained Positional Arguments</h1>
<p>The <code>positional_arg</code> shown in the first example is unconstrained, i.e. it will consume all command line tokens that follow. This isn't always desired, so we can use policies to constrain the amount of tokens consumed. Let's use a file copier as an example: </p><div class="fragment"><div class="line">$ simple-copy -f dest-dir source-path-1 source-path-2</div>
</div><!-- fragment --><p> Our simple copier takes multiple source paths and copies the files to a single destination directory, a 'force' flag will overwrite existing files silently. </p><div class="fragment"><div class="line">ar::root(</div>
<div class="line">    arp::validation::default_validator,</div>
<div class="line">    ar::help(<span class="stringliteral">&quot;help&quot;</span>_S, <span class="stringliteral">&quot;h&quot;</span>_S, <span class="stringliteral">&quot;Display this help and exit&quot;</span>_S),</div>
<div class="line">    ar::mode(</div>
<div class="line">        ar::flag(<span class="stringliteral">&quot;force&quot;</span>_S, <span class="stringliteral">&quot;f&quot;</span>_S, <span class="stringliteral">&quot;Force overwrite existing files&quot;</span>_S),</div>
<div class="line">        ar::positional_arg&lt;std::filesystem::path&gt;(<span class="stringliteral">&quot;DST&quot;</span>_S, <span class="stringliteral">&quot;Destination directory&quot;</span>_S,</div>
<div class="line">            arp::required,</div>
<div class="line">            arp::fixed_count&lt;1&gt;),</div>
<div class="line">        ar::positional_arg&lt;std::vector&lt;std::filesystem::path&gt;&gt;(<span class="stringliteral">&quot;SRC&quot;</span>_S, <span class="stringliteral">&quot;Source file paths&quot;</span>_S,</div>
<div class="line">            arp::required,</div>
<div class="line">            arp::min_count&lt;1&gt;),</div>
<div class="line">        arp::router{[](<span class="keywordtype">bool</span> force,</div>
<div class="line">                       std::filesystem::path dest,</div>
<div class="line">                       std::vector&lt;std::filesystem::path&gt; srcs) { ... }}))</div>
</div><!-- fragment --><p> It was noted in the <a href="#basics">Basics</a> section that ordering does matter for positional arguments, so we can see here that the destination path is specified first and therefore comes first on the command line. There can only be one destination path so we specify the <code>count</code> to one. Because the <code>count</code> is 1 the return type doesn't need to be a container.</p>
<p>Following the destination path are the source paths, we need at least one so we mark it as required, as our range is unbounded the <code>value_type</code> needs to be a container. <code>positional_arg</code> uses a <code>push_back</code> call on the container, so <code>std::vector</code> is the typical type to use.</p>
<p>Only the last <code>positional_arg</code> may be of variable length. A runtime error will only occur if there are no unbounded variable length <code>postional_arg</code>s and there are more arguments than the maximum or less than the minimum.</p>
<p>It should be noted that setting a non-zero minimum count (<code>min_count</code>, <code>fixed_count</code>, or <code>min_max_count</code>) does <em>not</em> imply a requirement, the minimum count check only applies when there is at least one argument for the node to process. So as with an <code>arg</code>, you should use a <code>required</code> policy to explicitly state that at least one argument needs to be present, or a <code>default_value</code> policy - otherwise a default initialised value will be used instead. For <code>positional_arg</code> nodes that are marked as <code>required</code>, it is a compile-time error to have a minimum count policy value of 0.</p>
<h1>Modes</h1>
<p>As noted in <a href="#basics">Basics</a>, <code>mode</code>s allow you to group command line components under an initial token on the command line. A common example of this developers will be aware of is <code>git</code>, for example in our parlance <code>git clean -ffxd</code>; <code>clean</code> would be the mode and <code>ffxd</code> would be be the flags that are available under that mode.</p>
<p>As an example, let's take the <code>simple-copy</code> above and split it into two modes: </p><div class="fragment"><div class="line">$ simple copy -f dest-dir source-path-1 source-path-2</div>
<div class="line">$ simple move -f dest-dir source-path-1</div>
</div><!-- fragment --> <div class="fragment"><div class="line">ar::root(</div>
<div class="line">    arp::validation::default_validator,</div>
<div class="line">    ar::help(<span class="stringliteral">&quot;help&quot;</span>_S, <span class="stringliteral">&quot;h&quot;</span>_S, <span class="stringliteral">&quot;Display this help and exit&quot;</span>_S),</div>
<div class="line">    ar::mode(</div>
<div class="line">        arp::none_name_t{<span class="stringliteral">&quot;copy&quot;</span>_S},</div>
<div class="line">        arp::description_t{<span class="stringliteral">&quot;Copy source files to destination&quot;</span>_S},</div>
<div class="line">        ar::flag(<span class="stringliteral">&quot;force&quot;</span>_S, <span class="stringliteral">&quot;f&quot;</span>_S, <span class="stringliteral">&quot;Force overwrite existing files&quot;</span>_S),</div>
<div class="line">        ar::positional_arg&lt;std::filesystem::path&gt;(<span class="stringliteral">&quot;DST&quot;</span>_S, <span class="stringliteral">&quot;Destination directory&quot;</span>_S,</div>
<div class="line">            arp::required,</div>
<div class="line">            arp::fixed_count&lt;1&gt;),</div>
<div class="line">        ar::positional_arg&lt;std::vector&lt;std::filesystem::path&gt;&gt;(<span class="stringliteral">&quot;SRC&quot;</span>_S, <span class="stringliteral">&quot;Source file paths&quot;</span>_S,</div>
<div class="line">            arp::required,</div>
<div class="line">            arp::min_count&lt;1&gt;),</div>
<div class="line">        arp::router{[](<span class="keywordtype">bool</span> force,</div>
<div class="line">                       std::filesystem::path dest,</div>
<div class="line">                       std::vector&lt;std::filesystem::path&gt; srcs) { ... }}),</div>
<div class="line">    ar::mode(<span class="stringliteral">&quot;move&quot;</span>_S, <span class="stringliteral">&quot;Move source file to destination&quot;</span>_S,</div>
<div class="line">        ar::flag(<span class="stringliteral">&quot;force&quot;</span>_S, <span class="stringliteral">&quot;f&quot;</span>_S, <span class="stringliteral">&quot;Force overwrite existing files&quot;</span>_S),</div>
<div class="line">        ar::positional_arg&lt;std::filesystem::path&gt;(<span class="stringliteral">&quot;DST&quot;</span>_S, <span class="stringliteral">&quot;Destination directory&quot;</span>_S,</div>
<div class="line">            arp::required,</div>
<div class="line">            arp::fixed_count&lt;1&gt;),</div>
<div class="line">        <span class="comment">// Can only have one</span></div>
<div class="line">        ar::positional_arg&lt;std::filesystem::path&gt;(<span class="stringliteral">&quot;SRC&quot;</span>_S, <span class="stringliteral">&quot;Source file path&quot;</span>_S,</div>
<div class="line">            arp::required,</div>
<div class="line">            arp::fixed_count&lt;1&gt;),</div>
<div class="line">        arp::router{[](<span class="keywordtype">bool</span> force,</div>
<div class="line">                       std::filesystem::path dest,</div>
<div class="line">                       std::filesystem::path src) { ... }}))</div>
</div><!-- fragment --><p> The name of a <code>mode</code> can only be the none version, as it doesn't use a prefix. We now have two named modes: <code>copy</code> and <code>move</code>.</p>
<p>Named <code>mode</code>s can be nested too! Only one mode can be invoked, so attempting to use flags from parent modes is a runtime failure. Another stipulation is that every <code>mode</code> needs a <code>router</code> unless <em>all</em> of its children are <code>mode</code>s as well.</p>
<h2>Flags Common Between Nodes</h2>
<p>An obvious ugliness to the above example is that we now have duplicated code. We can split that out, and then use copies in the root declaration. </p><div class="fragment"><div class="line">constexpr <span class="keyword">auto</span> common_args = ar::list{</div>
<div class="line">    ar::flag(<span class="stringliteral">&quot;force&quot;</span>_S, <span class="stringliteral">&quot;f&quot;</span>_S, <span class="stringliteral">&quot;Force overwrite existing files&quot;</span>_S),</div>
<div class="line">    ar::positional_arg&lt;std::filesystem::path&gt;(<span class="stringliteral">&quot;DST&quot;</span>_S, <span class="stringliteral">&quot;Destination directory&quot;</span>_S,</div>
<div class="line">        arp::required,</div>
<div class="line">        arp::fixed_count&lt;1&gt;)};</div>
<div class="line"> </div>
<div class="line">ar::root(</div>
<div class="line">    arp::validation::default_validator,</div>
<div class="line">    ar::mode(<span class="stringliteral">&quot;copy&quot;</span>_S, <span class="stringliteral">&quot;Copy source files to destination&quot;</span>_S,</div>
<div class="line">        common_args,</div>
<div class="line">        ar::positional_arg&lt;std::vector&lt;std::filesystem::path&gt;&gt;(<span class="stringliteral">&quot;SRC&quot;</span>_S, <span class="stringliteral">&quot;Source file paths&quot;</span>_S,</div>
<div class="line">            arp::required,</div>
<div class="line">            arp::min_count&lt;1&gt;),</div>
<div class="line">        arp::router{[](<span class="keywordtype">bool</span> force,</div>
<div class="line">                       std::filesystem::path dest,</div>
<div class="line">                       std::vector&lt;std::filesystem::path&gt; srcs) { ... }}),</div>
<div class="line">    ar::mode(<span class="stringliteral">&quot;move&quot;</span>_S, <span class="stringliteral">&quot;Move source file to destination&quot;</span>_S,</div>
<div class="line">        common_args,</div>
<div class="line">        ar::positional_arg&lt;std::filesystem::path&gt;(<span class="stringliteral">&quot;SRC&quot;</span>_S, <span class="stringliteral">&quot;Source file path&quot;</span>_S,</div>
<div class="line">            arp::required,</div>
<div class="line">            arp::fixed_count&lt;1&gt;),</div>
<div class="line">        arp::router{[](<span class="keywordtype">bool</span> force,</div>
<div class="line">                       std::filesystem::path dest,</div>
<div class="line">                       std::filesystem::path src) { ... }}))</div>
</div><!-- fragment --><p> <code>ar::list</code> is a simple <code>arg</code> and <code>flag</code> container that <code>mode</code> and <code>root</code> instances detect and add the contents to their child/policy lists. Also don't be afraid of the copies, the majority of <code><a class="el" href="namespacearg__router.html">arg_router</a></code> types hold no data (the advantage of compile-time!) and those that do (e.g. <code>default_value</code>) generally have small types like primitives or <code>std::string_view</code>.</p>
<h1>Help Output</h1>
<p>As shown in prior sections, a <code>help</code> node can be a child of the <code>root</code> (and only the <code>root</code>!), which acts like an <code>arg</code>, and generates the help output when requested by the user. This node is optional, without it there is no help command line argument. As the node is <code>arg</code>-like, it requires a long and/or short name.</p>
<p>The output can be embellished with the following policies:</p><ul>
<li><code>program_name_t</code>, the name of the program as it should be displayed to the user</li>
<li><code>program_version_t</code>, version string. This is not shown if a <code>program_name_t</code> is not specified</li>
<li><code>program_intro_t</code>, used to give some more information on the program, before the argument ouput</li>
<li><code>program_addendum_t</code>, used to add supplementary text after the argument output</li>
<li><code>flatten_help_t</code>, by default only top-level arguments and/or those in an anonymous mode are displayed. Child modes are shown by requesting the mode's 'path' on the command line (e.g. <code>app --help mode sub-mode</code>). The presence of this policy will make the entire requested subtree's (or root's, if no mode path was requested) help output be displayed</li>
</ul>
<p>Unlike string data everywhere else in the library, the formatted help output is created at runtime so we don't need to keep duplicate read-only text data.</p>
<p>For example the slightly embellished tree from above: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> common_args = ar::list{</div>
<div class="line">    ar::flag(<span class="stringliteral">&quot;force&quot;</span>_S, <span class="stringliteral">&quot;f&quot;</span>_S, <span class="stringliteral">&quot;Force overwrite existing files&quot;</span>_S),</div>
<div class="line">    ar::positional_arg&lt;std::filesystem::path&gt;(<span class="stringliteral">&quot;DST&quot;</span>_S, <span class="stringliteral">&quot;Destination directory&quot;</span>_S,</div>
<div class="line">        arp::required,</div>
<div class="line">        arp::fixed_count&lt;1&gt;)};</div>
<div class="line"> </div>
<div class="line">ar::root(</div>
<div class="line">    arp::validation::default_validator,</div>
<div class="line">    ar::help(<span class="stringliteral">&quot;help&quot;</span>_S, <span class="stringliteral">&quot;h&quot;</span>_S, <span class="stringliteral">&quot;Display this help and exit&quot;</span>_S,</div>
<div class="line">        arp::program_name_t{<span class="stringliteral">&quot;simple&quot;</span>_S},</div>
<div class="line">        arp::program_version_t{<span class="stringliteral">&quot;v0.1&quot;</span>_S},</div>
<div class="line">        arp::program_intro_t{<span class="stringliteral">&quot;A simple file copier and mover.&quot;</span>_S},</div>
<div class="line">        arp::program_addendum_t{<span class="stringliteral">&quot;An example program for arg_router.&quot;</span>_S},</div>
<div class="line">        arp::flatten_help),</div>
<div class="line">    ar::mode(<span class="stringliteral">&quot;copy&quot;</span>_S, <span class="stringliteral">&quot;Copy source files to destination&quot;</span>_S,</div>
<div class="line">        common_args,</div>
<div class="line">        ar::positional_arg&lt;std::vector&lt;std::filesystem::path&gt;&gt;(<span class="stringliteral">&quot;SRC&quot;</span>_S, <span class="stringliteral">&quot;Source file paths&quot;</span>_S,</div>
<div class="line">            arp::required,</div>
<div class="line">            arp::min_count&lt;1&gt;),</div>
<div class="line">        arp::router{[](<span class="keywordtype">bool</span> force,</div>
<div class="line">                       std::filesystem::path dest,</div>
<div class="line">                       std::vector&lt;std::filesystem::path&gt; srcs) { ... }}),</div>
<div class="line">    ar::mode(<span class="stringliteral">&quot;move&quot;</span>_S, <span class="stringliteral">&quot;Move source file to destination&quot;</span>_S,</div>
<div class="line">        common_args,</div>
<div class="line">        ar::positional_arg&lt;std::filesystem::path&gt;(<span class="stringliteral">&quot;SRC&quot;</span>_S, <span class="stringliteral">&quot;Source file path&quot;</span>_S,</div>
<div class="line">            arp::required,</div>
<div class="line">            arp::fixed_count&lt;1&gt;),</div>
<div class="line">        arp::router{[](<span class="keywordtype">bool</span> force,</div>
<div class="line">                       std::filesystem::path dest,</div>
<div class="line">                       std::filesystem::path src) { ... }}))</div>
</div><!-- fragment --><p> Would output this to the terminal: </p><div class="fragment"><div class="line">$ simple --help</div>
<div class="line">simple v0.1</div>
<div class="line"> </div>
<div class="line">A simple file copier and mover.</div>
<div class="line"> </div>
<div class="line">    --help,-h         Display this help and exit</div>
<div class="line">    copy              Copy source files to destination</div>
<div class="line">        --force,-f    Force overwrite existing files</div>
<div class="line">        &lt;DST&gt; [1]     Destination directory</div>
<div class="line">        &lt;SRC&gt; [1,N]   Source file paths</div>
<div class="line">    move              Move source file to destination</div>
<div class="line">        --force,-f    Force overwrite existing files</div>
<div class="line">        &lt;DST&gt; [1]     Destination directory</div>
<div class="line">        &lt;SRC&gt; [1]     Source file path</div>
<div class="line"> </div>
<div class="line">An example program for arg_router.</div>
</div><!-- fragment --><p> As you can see positional arguments are wrapped in angle brackets, and counts are displayed using interval notation.</p>
<p>Removing the <code>flatten_help</code> policy would change it to this: </p><div class="fragment"><div class="line">$ simple --help</div>
<div class="line">simple v0.1</div>
<div class="line"> </div>
<div class="line">A simple file copier and mover.</div>
<div class="line"> </div>
<div class="line">    --help,-h    Display this help and exit</div>
<div class="line">    copy         Copy source files to destination</div>
<div class="line">    move         Move source file to destination</div>
<div class="line"> </div>
<div class="line">An example program for arg_router.</div>
</div><!-- fragment --><p> In either case specifying the mode as an argument to the help argument displays just the sub-arguments of that mode: </p><div class="fragment"><div class="line">$ simple --help copy</div>
<div class="line">simple v0.1</div>
<div class="line"> </div>
<div class="line">A simple file copier and mover.</div>
<div class="line"> </div>
<div class="line">copy              Copy source files to destination</div>
<div class="line">    --force,-f    Force overwrite existing files</div>
<div class="line">    &lt;DST&gt; [1]     Destination directory</div>
<div class="line">    &lt;SRC&gt; [1,N]   Source file paths</div>
<div class="line"> </div>
<div class="line">An example program for arg_router.</div>
</div><!-- fragment --> <h2>Programmatic Access</h2>
<p>By default when parsed, <code>help</code> will output its contents to <code>std::cout</code> and then exit the application with <code>EXIT_SUCCESS</code>. Obviously this won't always be desired, so a <code>router</code> policy can be attached that will pass a <code>std::ostringstream</code> to the user-provided <code>Callable</code>. The stream will have already been populated with the help data shown above, but it can now be appended to or converted to string for use somewhere else.</p>
<p>Often programmatic access is desired for the help output outside of the user requesting it, for example if a parse exception is thrown, generally the exception error is printed to the terminal followed by the help output. This is exposed by the <code>help()</code> or <code>help(std::ostringstream&amp;)</code> methods of the root object.</p>
<h2>Customisation</h2>
<p>Help output can be customised in several ways:</p><ol type="1">
<li>Use a <code>router</code> policy to capture the output and modify it. This is useful for appending string data, but anything more sophisticated becomes a chore</li>
<li>Write your own <code>help</code> node. This is the nuclear option as it gives maximal control but is a lot of work, it is very rarely necessary to do this as the node is primarily just the <code>tree_node</code> implementation, the actual formatting is delegated</li>
<li>Write your own help formatter policy for the built-in <code>help</code> node. The <code>help</code> node delegates the formatting to a policy, if no formatter is specified when defining a <code>help</code> node specialisation the <code>default_help_formatter</code> is used. This is still non-trivial as the formatter policy needs to perform the compile-time tree iteration in order to process the per-node help data</li>
<li>Write your own line formatter and/or preamble formatter. The <code>default_help_formatter</code> further delegates formatting to three sub-policies, one that generates the 'preamble' text (i.e. the program name, version, intro), another that generates each argument in the argument output, and a final one to generate the addendum. <code>default_helper_formatter</code> uses <code>help_formatter_component::default_preamble_formatter</code>, <code>help_formatter_component::default_line_formatter</code>, and <code>help_formatter_component::default_addendum_formatter</code> respectively by default</li>
</ol>
<h1>Unicode Compliance</h1>
<p>A faintly ridiculous example of Unicode support from the <code>just_cats</code> example: </p><div class="fragment"><div class="line">$ ./example_just_cats -h</div>
<div class="line">just-cats</div>
<div class="line"> </div>
<div class="line">Prints cats!</div>
<div class="line"> </div>
<div class="line">    --help,-h    Display this help and exit</div>
<div class="line">    --cat        English cat</div>
<div class="line">    -猫          日本語の猫</div>
<div class="line">    -🐱          Emoji cat</div>
<div class="line">    --แมว        แมวไทย</div>
<div class="line">    --кіт        український кіт</div>
<div class="line">$ ./example_just_cats --cat</div>
<div class="line">cat</div>
<div class="line">$ ./example_just_cats -猫</div>
<div class="line">猫</div>
<div class="line">$ ./example_just_cats -🐱</div>
<div class="line">🐱</div>
<div class="line">$ ./example_just_cats --แมว</div>
<div class="line">แมว</div>
<div class="line">$ ./example_just_cats --кіт</div>
<div class="line">кіт</div>
</div><!-- fragment --><p><code><a class="el" href="namespacearg__router.html">arg_router</a></code> only supports UTF-8 encoding, and will stay that way for the medium term. If you want other encodings (e.g. UTF-16 on Windows), then you'll need to convert the input tokens to UTF-8 before calling <code>parse(..)</code>. The compile-time strings used in the parse tree <em>must</em> be UTF-8 because that's the only encoding supported by <code><a class="el" href="namespacearg__router.html">arg_router</a></code>'s string checkers and line-break algorithm. Likewise the help output generated will be UTF-8, so you'll need to capture the output (by attaching a <code>policy::router</code>) and then convert before printing</p>
<h2>Why have you written your own Unicode algorithms!?</h2>
<p>We didn't want to... Normally an application will link to ICU for its Unicode needs, but unfortunately we can't do that here as ICU is not <code>constexpr</code> and therefore cannot be used for our compile-time needs - so we need to roll our own.</p>
<h1>Runtime Language Selection</h1>
<p><code><a class="el" href="namespacearg__router.html">arg_router</a></code> has support for runtime language selection, using <code>multi_lang::root</code>. This wraps around a <code>Callable</code> that returns a <code>root</code> instance 'tweaked' for a given language. Let's take the start of the simple file copier/mover application and convert it to use <code>multi_lang::root</code> - start by defining translations of the tree's strings: </p><div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code" href="namespacearg__router_1_1multi__lang.html">arg_router::multi_lang</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">template</span> &lt;&gt;</div>
<div class="line"><span class="keyword">class </span>translation&lt;str&lt;&quot;en_GB&quot;&gt;&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">using</span> force = str&lt;<span class="stringliteral">&quot;force&quot;</span>&gt;;</div>
<div class="line">    <span class="keyword">using</span> force_description = str&lt;<span class="stringliteral">&quot;Force overwrite existing files&quot;</span>&gt;;</div>
<div class="line">    <span class="keyword">using</span> destination = str&lt;<span class="stringliteral">&quot;DST&quot;</span>&gt;;</div>
<div class="line">    <span class="keyword">using</span> destination_description = str&lt;<span class="stringliteral">&quot;Destination directory&quot;</span>&gt;;</div>
<div class="line">    <span class="keyword">using</span> <a class="code" href="namespacearg__router.html#a1eb8c408da38619d624f435441efac48">help</a> = str&lt;<span class="stringliteral">&quot;help&quot;</span>&gt;;</div>
<div class="line">    <span class="keyword">using</span> help_description = str&lt;<span class="stringliteral">&quot;Display this help and exit&quot;</span>&gt;;</div>
<div class="line">    <span class="keyword">using</span> <a class="code" href="namespacearg__router_1_1policy.html#ae4c0515ad6d58ea37fe121ee3f4a9861">program_intro</a> = str&lt;<span class="stringliteral">&quot;A simple file copier and mover.&quot;</span>&gt;;</div>
<div class="line">    <span class="keyword">using</span> <a class="code" href="namespacearg__router_1_1policy.html#a50ebcd2455ba90ecbbcaf7d6aab2dc16">program_addendum</a> = str&lt;<span class="stringliteral">&quot;An example program for arg_router.&quot;</span>&gt;;</div>
<div class="line">    <span class="keyword">using</span> copy = str&lt;<span class="stringliteral">&quot;copy&quot;</span>&gt;;</div>
<div class="line">    <span class="keyword">using</span> copy_description = str&lt;<span class="stringliteral">&quot;Copy source files to destination&quot;</span>&gt;;</div>
<div class="line">    <span class="keyword">using</span> source = str&lt;<span class="stringliteral">&quot;SRC&quot;</span>&gt;;</div>
<div class="line">    <span class="keyword">using</span> sources_description = str&lt;<span class="stringliteral">&quot;Source file paths&quot;</span>&gt;;</div>
<div class="line">    <span class="keyword">using</span> move = str&lt;<span class="stringliteral">&quot;move&quot;</span>&gt;;</div>
<div class="line">    <span class="keyword">using</span> move_description = str&lt;<span class="stringliteral">&quot;Move source file to destination&quot;</span>&gt;;</div>
<div class="line">    <span class="keyword">using</span> source_description = str&lt;<span class="stringliteral">&quot;Source file path&quot;</span>&gt;;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;&gt;</div>
<div class="line"><span class="keyword">class </span>translation&lt;str&lt;&quot;fr&quot;&gt;&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">using</span> force = str&lt;<span class="stringliteral">&quot;forcer&quot;</span>&gt;;</div>
<div class="line">    <span class="keyword">using</span> force_description = str&lt;<span class="stringliteral">&quot;Forcer l&#39;écrasement des fichiers existants&quot;</span>&gt;;</div>
<div class="line">    <span class="keyword">using</span> destination = str&lt;<span class="stringliteral">&quot;DST&quot;</span>&gt;;</div>
<div class="line">    <span class="keyword">using</span> destination_description = str&lt;<span class="stringliteral">&quot;Répertoire de destination&quot;</span>&gt;;</div>
<div class="line">    <span class="keyword">using</span> <a class="code" href="namespacearg__router.html#a1eb8c408da38619d624f435441efac48">help</a> = str&lt;<span class="stringliteral">&quot;aider&quot;</span>&gt;;</div>
<div class="line">    <span class="keyword">using</span> help_description = str&lt;<span class="stringliteral">&quot;Afficher cette aide et quitter&quot;</span>&gt;;</div>
<div class="line">    <span class="keyword">using</span> <a class="code" href="namespacearg__router_1_1policy.html#ae4c0515ad6d58ea37fe121ee3f4a9861">program_intro</a> = str&lt;<span class="stringliteral">&quot;Un simple copieur et déménageur de fichiers.&quot;</span>&gt;;</div>
<div class="line">    <span class="keyword">using</span> <a class="code" href="namespacearg__router_1_1policy.html#a50ebcd2455ba90ecbbcaf7d6aab2dc16">program_addendum</a> = str&lt;<span class="stringliteral">&quot;Un exemple de programme pour arg_router.&quot;</span>&gt;;</div>
<div class="line">    <span class="keyword">using</span> copy = str&lt;<span class="stringliteral">&quot;copier&quot;</span>&gt;;</div>
<div class="line">    <span class="keyword">using</span> copy_description = str&lt;<span class="stringliteral">&quot;Copier les fichiers source vers la destination&quot;</span>&gt;;</div>
<div class="line">    <span class="keyword">using</span> source = str&lt;<span class="stringliteral">&quot;SRC&quot;</span>&gt;;</div>
<div class="line">    <span class="keyword">using</span> sources_description = str&lt;<span class="stringliteral">&quot;Chemins des fichiers sources&quot;</span>&gt;;</div>
<div class="line">    <span class="keyword">using</span> move = str&lt;<span class="stringliteral">&quot;déplacer&quot;</span>&gt;;</div>
<div class="line">    <span class="keyword">using</span> move_description = str&lt;<span class="stringliteral">&quot;Déplacer le fichier source vers la destination&quot;</span>&gt;;</div>
<div class="line">    <span class="keyword">using</span> source_description = str&lt;<span class="stringliteral">&quot;Chemin du fichier source&quot;</span>&gt;;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;&gt;</div>
<div class="line"><span class="keyword">class </span>translation&lt;str&lt;&quot;ja&quot;&gt;&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">using</span> force = str&lt;<span class="stringliteral">&quot;強制&quot;</span>&gt;;</div>
<div class="line">    <span class="keyword">using</span> force_description = str&lt;<span class="stringliteral">&quot;既存のファイルを強制的に上書きする&quot;</span>&gt;;</div>
<div class="line">    <span class="keyword">using</span> destination = str&lt;<span class="stringliteral">&quot;先&quot;</span>&gt;;</div>
<div class="line">    <span class="keyword">using</span> destination_description = str&lt;<span class="stringliteral">&quot;宛先ディレクトリ&quot;</span>&gt;;</div>
<div class="line">    <span class="keyword">using</span> <a class="code" href="namespacearg__router.html#a1eb8c408da38619d624f435441efac48">help</a> = str&lt;<span class="stringliteral">&quot;ヘルプ&quot;</span>&gt;;</div>
<div class="line">    <span class="keyword">using</span> help_description = str&lt;<span class="stringliteral">&quot;このヘルプを表示して終了&quot;</span>&gt;;</div>
<div class="line">    <span class="keyword">using</span> <a class="code" href="namespacearg__router_1_1policy.html#ae4c0515ad6d58ea37fe121ee3f4a9861">program_intro</a> = str&lt;<span class="stringliteral">&quot;ファイルをコピーおよび移動するためのシンプルなプログラム。&quot;</span>&gt;;</div>
<div class="line">    <span class="keyword">using</span> <a class="code" href="namespacearg__router_1_1policy.html#a50ebcd2455ba90ecbbcaf7d6aab2dc16">program_addendum</a> = str&lt;<span class="stringliteral">&quot;「arg_router」のサンプルプログラム。&quot;</span>&gt;;</div>
<div class="line">    <span class="keyword">using</span> copy = str&lt;<span class="stringliteral">&quot;コピー&quot;</span>&gt;;</div>
<div class="line">    <span class="keyword">using</span> copy_description = str&lt;<span class="stringliteral">&quot;ソース ファイルを宛先にコピーする&quot;</span>&gt;;</div>
<div class="line">    <span class="keyword">using</span> source = str&lt;<span class="stringliteral">&quot;出典&quot;</span>&gt;;</div>
<div class="line">    <span class="keyword">using</span> sources_description = str&lt;<span class="stringliteral">&quot;ソース ファイルのパス&quot;</span>&gt;;</div>
<div class="line">    <span class="keyword">using</span> move = str&lt;<span class="stringliteral">&quot;移動&quot;</span>&gt;;</div>
<div class="line">    <span class="keyword">using</span> move_description = str&lt;<span class="stringliteral">&quot;ソース ファイルを宛先に移動する&quot;</span>&gt;;</div>
<div class="line">    <span class="keyword">using</span> source_description = str&lt;<span class="stringliteral">&quot;ソース ファイル パス&quot;</span>&gt;;</div>
<div class="line">};</div>
<div class="line">}  <span class="comment">// namespace arg_router::multi_lang</span></div>
<div class="ttc" id="anamespacearg__router_1_1multi__lang_html"><div class="ttname"><a href="namespacearg__router_1_1multi__lang.html">arg_router::multi_lang</a></div><div class="ttdef"><b>Definition:</b> <a href="iso__locale_8hpp_source.html#l00009">iso_locale.hpp:10</a></div></div>
<div class="ttc" id="anamespacearg__router_1_1policy_html_a50ebcd2455ba90ecbbcaf7d6aab2dc16"><div class="ttname"><a href="namespacearg__router_1_1policy.html#a50ebcd2455ba90ecbbcaf7d6aab2dc16">arg_router::policy::program_addendum</a></div><div class="ttdeci">constexpr auto program_addendum</div><div class="ttdef"><b>Definition:</b> <a href="program__addendum_8hpp_source.html#l00053">program_addendum.hpp:53</a></div></div>
<div class="ttc" id="anamespacearg__router_1_1policy_html_ae4c0515ad6d58ea37fe121ee3f4a9861"><div class="ttname"><a href="namespacearg__router_1_1policy.html#ae4c0515ad6d58ea37fe121ee3f4a9861">arg_router::policy::program_intro</a></div><div class="ttdeci">constexpr auto program_intro</div><div class="ttdef"><b>Definition:</b> <a href="program__intro_8hpp_source.html#l00053">program_intro.hpp:53</a></div></div>
<div class="ttc" id="anamespacearg__router_html_a1eb8c408da38619d624f435441efac48"><div class="ttname"><a href="namespacearg__router.html#a1eb8c408da38619d624f435441efac48">arg_router::help</a></div><div class="ttdeci">constexpr auto help(Policies... policies) noexcept</div><div class="ttdef"><b>Definition:</b> <a href="help_8hpp_source.html#l00233">help.hpp:233</a></div></div>
</div><!-- fragment --><p> There is nothing special about the <code>translation</code> type, the unspecialised version will simply static assert if used to remind you to implement specialisations for all language IDs (the template parameter type) - otherwise it is just an empty type. Its use is still recommended though as functionality may be added to it in the future. </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Apologies for any translation faux pas - Google Translate did it for me!</span></div>
<div class="line">    ar::multi_lang::root&lt;ar::str&lt;<span class="stringliteral">&quot;en_GB&quot;</span>&gt;, ar::str&lt;<span class="stringliteral">&quot;fr&quot;</span>&gt;, ar::str&lt;<span class="stringliteral">&quot;ja&quot;</span>&gt;&gt;(  <span class="comment">//</span></div>
<div class="line">        ar::multi_lang::iso_locale(locale_name()),</div>
<div class="line">        [&amp;](<span class="keyword">auto</span> tr_) {</div>
<div class="line">            <span class="comment">// This isn&#39;t necessary with C++20 lambda template params</span></div>
<div class="line">            <span class="keyword">using</span> tr = decltype(tr_);</div>
<div class="line"> </div>
<div class="line">            <span class="keyword">const</span> <span class="keyword">auto</span> common_args = ar::list{</div>
<div class="line">                ar::flag(<span class="keyword">typename</span> tr::force{}, <span class="stringliteral">&quot;f&quot;</span>_S, <span class="keyword">typename</span> tr::force_description{}),</div>
<div class="line">                ar::positional_arg&lt;fs::path&gt;(<span class="keyword">typename</span> tr::destination{},</div>
<div class="line">                                             <span class="keyword">typename</span> tr::destination_description{},</div>
<div class="line">                                             arp::required,</div>
<div class="line">                                             arp::fixed_count&lt;1&gt;)};</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">return</span> ar::root(</div>
<div class="line">                arp::validation::default_validator,</div>
<div class="line">                ar::help(<span class="keyword">typename</span> tr::help{}, <span class="stringliteral">&quot;h&quot;</span>_S, <span class="keyword">typename</span> tr::help_description{},</div>
<div class="line">                         arp::program_name_t{<span class="stringliteral">&quot;simple&quot;</span>_S},</div>
<div class="line">                         arp::program_version_t{<span class="stringliteral">&quot;v0.1&quot;</span>_S},</div>
<div class="line">                         arp::program_intro&lt;typename tr::program_intro&gt;,</div>
<div class="line">                         arp::program_addendum&lt;typename tr::program_addendum&gt;,</div>
<div class="line">                         arp::flatten_help,</div>
<div class="line">                         arp::colour_help_formatter),</div>
<div class="line">                ...</div>
<div class="line">        );</div>
<div class="line">    }).parse(argc, argv);</div>
</div><!-- fragment --><p> <code>multi_lang::root</code> takes a set of supported language identifiers (ISO language/country codes are recommended for readability/ease, but not required), these are used as the language IDs for <code>translation</code> specialisation. The runtime-selected <code>translation</code> instance is then passed to the <code>Callable</code> provided to <code>multi_lang::root</code>, the type of which is then used to access the translated compile-time string. Any missing string translation will cause a compilation error.</p>
<p>The first argument to <code>multi_lang::root</code> is a string provided by the user that should match one of the language identifiers, if it doesn't <code><a class="el" href="namespacearg__router.html">arg_router</a></code> will fall back to using the first defined language (UK English in this case). As a convenience <code><a class="el" href="namespacearg__router.html">arg_router</a></code> provides a simple function that takes the OS locale name and standardises it to an ISO language/country identifier.</p>
<p><code>multi_lang::root</code>'s interface is designed to mimic <code>ar::root</code>, so it can be used as a drop in replacement.</p>
<p>The above code (which is available as a <a href="https://cmannett85.github.io/arg_router/c_09_0920_2simple_ml_2main_8cpp-example.html">buildable example</a>) will yield the following help output: </p><div class="fragment"><div class="line">$ ./example_simple_ml_cpp20 -h</div>
<div class="line">simple v0.1</div>
<div class="line"> </div>
<div class="line">A simple file copier and mover.</div>
<div class="line"> </div>
<div class="line">    --help,-h          Display this help and exit</div>
<div class="line">    copy               Copy source files to destination</div>
<div class="line">        --force,-f     Force overwrite existing files</div>
<div class="line">        &lt;DST&gt; [1]      Destination directory</div>
<div class="line">        &lt;SRC&gt; [1,N]    Source file paths</div>
<div class="line">    move               Move source file to destination</div>
<div class="line">        --force,-f     Force overwrite existing files</div>
<div class="line">        &lt;DST&gt; [1]      Destination directory</div>
<div class="line">        &lt;SRC&gt; [1]      Source file path</div>
<div class="line"> </div>
<div class="line">An example program for arg_router.</div>
<div class="line"> </div>
<div class="line">$ AR_LOCALE_OVERRIDE=fr ./example_simple_ml_cpp20 -h</div>
<div class="line">simple v0.1</div>
<div class="line"> </div>
<div class="line">Un simple copieur et déménageur de fichiers.</div>
<div class="line"> </div>
<div class="line">    --aider,-h         Afficher cette aide et quitter</div>
<div class="line">    copier             Copier les fichiers source vers la destination</div>
<div class="line">        --forcer,-f    Forcer l&#39;écrasement des fichiers existants</div>
<div class="line">        &lt;DST&gt; [1]      Répertoire de destination</div>
<div class="line">        &lt;SRC&gt; [1,N]    Chemins des fichiers sources</div>
<div class="line">    déplacer           Déplacer le fichier source vers la destination</div>
<div class="line">        --forcer,-f    Forcer l&#39;écrasement des fichiers existants</div>
<div class="line">        &lt;DST&gt; [1]      Répertoire de destination</div>
<div class="line">        &lt;SRC&gt; [1]      Chemin du fichier source</div>
<div class="line"> </div>
<div class="line">Un exemple de programme pour arg_router.</div>
<div class="line"> </div>
<div class="line">$ AR_LOCALE_OVERRIDE=ja ./example_simple_ml_cpp20 -h</div>
<div class="line">simple v0.1</div>
<div class="line"> </div>
<div class="line">ファイルをコピーおよび移動するためのシンプルなプログラム。</div>
<div class="line"> </div>
<div class="line">    --ヘルプ,-h         このヘルプを表示して終了</div>
<div class="line">    コピー              ソース ファイルを宛先にコピーする</div>
<div class="line">        --強制,-f       既存のファイルを強制的に上書きする</div>
<div class="line">        &lt;先&gt; [1]        宛先ディレクトリ</div>
<div class="line">        &lt;出典&gt; [1,N]    ソース ファイルのパス</div>
<div class="line">    移動                ソース ファイルを宛先に移動する</div>
<div class="line">        --強制,-f       既存のファイルを強制的に上書きする</div>
<div class="line">        &lt;先&gt; [1]        宛先ディレクトリ</div>
<div class="line">        &lt;出典&gt; [1]      ソース ファイル パス</div>
<div class="line"> </div>
<div class="line">「arg_router」のサンプルプログラム。</div>
<div class="line"> </div>
<div class="line">$ AR_LOCALE_OVERRIDE=foo ./example_simple_ml_cpp20 -h</div>
<div class="line">simple v0.1</div>
<div class="line"> </div>
<div class="line">A simple file copier and mover.</div>
<div class="line"> </div>
<div class="line">    --help,-h          Display this help and exit</div>
<div class="line">    copy               Copy source files to destination</div>
<div class="line">        --force,-f     Force overwrite existing files</div>
<div class="line">        &lt;DST&gt; [1]      Destination directory</div>
<div class="line">        &lt;SRC&gt; [1,N]    Source file paths</div>
<div class="line">    move               Move source file to destination</div>
<div class="line">        --force,-f     Force overwrite existing files</div>
<div class="line">        &lt;DST&gt; [1]      Destination directory</div>
<div class="line">        &lt;SRC&gt; [1]      Source file path</div>
<div class="line"> </div>
<div class="line">An example program for arg_router.</div>
</div><!-- fragment --><p> Optionally, you can also provide translations for the exception messages by defining an <code>error_code_translations</code> subtype that consists of a tuple of pairs that form a mapping between the error code and translation string. If this isn't provided then an internal <code>en_GB</code> one is automatically used instead. </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;&gt;</div>
<div class="line"><span class="keyword">class </span>translation&lt;str&lt;&quot;ja&quot;&gt;&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    ...</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">using</span> error_code_translations = std::tuple&lt;</div>
<div class="line">        std::pair&lt;traits::integral_constant&lt;error_code::unknown_argument&gt;, str&lt;<span class="stringliteral">&quot;不明な引数&quot;</span>&gt;&gt;,</div>
<div class="line">        std::pair&lt;traits::integral_constant&lt;error_code::unhandled_arguments&gt;, str&lt;<span class="stringliteral">&quot;未処理の引数&quot;</span>&gt;&gt;,</div>
<div class="line">        std::pair&lt;traits::integral_constant&lt;error_code::argument_has_already_been_set&gt;,</div>
<div class="line">                  str&lt;<span class="stringliteral">&quot;引数はすでに設定されています&quot;</span>&gt;&gt;,</div>
<div class="line">        std::pair&lt;traits::integral_constant&lt;error_code::failed_to_parse&gt;,</div>
<div class="line">                  str&lt;<span class="stringliteral">&quot;解析に失敗しました&quot;</span>&gt;&gt;,</div>
<div class="line">        std::pair&lt;traits::integral_constant&lt;error_code::no_arguments_passed&gt;,</div>
<div class="line">                  str&lt;<span class="stringliteral">&quot;引数が渡されませんでした&quot;</span>&gt;&gt;,</div>
<div class="line">        std::pair&lt;traits::integral_constant&lt;error_code::minimum_value_not_reached&gt;,</div>
<div class="line">                  str&lt;<span class="stringliteral">&quot;最小値に達していません&quot;</span>&gt;&gt;,</div>
<div class="line">        std::pair&lt;traits::integral_constant&lt;error_code::maximum_value_exceeded&gt;,</div>
<div class="line">                  str&lt;<span class="stringliteral">&quot;最大値を超えました&quot;</span>&gt;&gt;,</div>
<div class="line">        std::pair&lt;traits::integral_constant&lt;error_code::minimum_count_not_reached&gt;,</div>
<div class="line">                  str&lt;<span class="stringliteral">&quot;最小数に達していません&quot;</span>&gt;&gt;,</div>
<div class="line">        std::pair&lt;traits::integral_constant&lt;error_code::mode_requires_arguments&gt;,</div>
<div class="line">                  str&lt;<span class="stringliteral">&quot;モードには引数が必要です&quot;</span>&gt;&gt;,</div>
<div class="line">        std::pair&lt;traits::integral_constant&lt;error_code::missing_required_argument&gt;,</div>
<div class="line">                  str&lt;<span class="stringliteral">&quot;必要な引数がありません&quot;</span>&gt;&gt;,</div>
<div class="line">        std::pair&lt;traits::integral_constant&lt;error_code::too_few_values_for_alias&gt;,</div>
<div class="line">                  str&lt;<span class="stringliteral">&quot;エイリアス値が少なすぎる&quot;</span>&gt;&gt;,</div>
<div class="line">        std::pair&lt;</div>
<div class="line">            traits::integral_constant&lt;error_code::dependent_argument_missing&gt;,</div>
<div class="line">            str&lt;<span class="stringliteral">&quot;従属引数がありません (コマンドラインで必要なトークンの前に置く必要があります)&quot;</span>&gt;&gt;&gt;;</div>
<div class="line">};</div>
</div><!-- fragment --><p> Could yield: </p><div class="fragment"><div class="line">$ AR_LOCALE_OVERRIDE=ja ./example_simple_ml_cpp20 -🐱</div>
<div class="line">terminate called after throwing an instance of &#39;arg_router::parse_exception&#39;</div>
<div class="line">  what():  不明な引数: -🐱</div>
</div><!-- fragment --><h2>Note</h2>
<p><code>multi_lang::root_wrapper</code> from v1.0 is still present and supported, but is now marked as deprecated - new code should use <code>multi_lang::root</code>. It is not supported when using C++20 compile-time strings (see <a href="#compile-time-string-support">compile-time string support</a>).</p>
<h1>Compile-time String Support</h1>
<p>In v1.0 the library exclusively used the <code><a class="el" href="compile__time__string_8hpp.html#a741f251b243f90ef2b4d915e50d40bac">S_()</a></code> macro for compile-time string generation, this was an almost necessary convenience as that version of C++ had relatively poor NTTP support. In v1.1 we added an alternative for those using C++20 and above, which is the <code>str</code> type and its <code>""_S</code> string literal.</p>
<p>For those targetting C++20 with existing v1.0 code, upgrading to a newer library version will cause a compilation failure as the two methods are not compatible. But don't worry! Code changes aren't ncessary, but you will need to add the define <code>AR_DISABLE_CPP20_STRINGS=true</code> to your build. Those still targetting C++17 will not need to do anything.</p>
<p><b>Note</b> C++17 will be supported as a first class citizen until v2.0, after that C++20 will be the minimum so I can strip out a ton of code and get better diagnostics by using concepts.</p>
<h1>Error Handling</h1>
<p>Currently <code><a class="el" href="namespacearg__router.html">arg_router</a></code> only supports exceptions as error handling. If a parsing fails for some reason a <code><a class="el" href="classarg__router_1_1parse__exception.html">arg_router::parse_exception</a></code> is thrown carrying information on the failure.</p>
<h1>Installation and Dependencies</h1>
<p>If you're simply a library user, then download the pre-packaged release and install somewhere. You will need the following dependencies in order to build:</p><ul>
<li>Boost.mp11 v1.74+</li>
<li>Boost.Lexical_Cast v1.74+</li>
<li>Boost.Preprocessor v1.74+ (only needed if building against C++17)</li>
<li><a href="https://github.com/martinmoene/span-lite">span-lite</a> (only needed if building against C++17)</li>
</ul>
<p><code><a class="el" href="namespacearg__router.html">arg_router</a></code> is header-only (due to all the templates) and so are the above dependencies.</p>
<p><b>Note</b> currently <a class="el" href="namespacearg__router.html">arg_router</a> requires exception support, but <em>not</em> RTTI.</p>
<p>To get a pre-release <code><a class="el" href="namespacearg__router.html">arg_router</a></code>, or build the unit tests and examples, simply check out the repo and build via CMake in the usual way - the unit tests will be built by default: </p><div class="fragment"><div class="line">$ cd arg_router</div>
<div class="line">$ mkdir build</div>
<div class="line">$ cd ./build</div>
<div class="line">$ cmake -G &quot;Ninja&quot; ..</div>
<div class="line">$ cmake --build .</div>
<div class="line">$ cmake --install .</div>
</div><!-- fragment --><p> Building these targets will require more dependencies:</p><ul>
<li>clang-format</li>
<li>Python v3 (used for copyright checking)</li>
<li>Doxygen</li>
<li>Boost.Test v1.74+</li>
<li>Boost.Filesystem v1.74+</li>
<li>Boost.Process v1.74+</li>
</ul>
<p>By default all these dependencies are provided by <code>vcpkg</code> automatically, please <b>note</b> that <code>vcpkg</code> is provided via a submodule and therefore will need initialising (<code>git submodule update</code>). If you would rather the dependencies came from the system then simply set <code>-DDISABLE_VCPKG=OFF</code>, and CMake will not bootstrap <code>vcpkg</code> and therefore try to find the packages locally.</p>
<h1>Configuration</h1>
<p>Low-level tweaking of the library is achieved via some defines and/or CMake variables, documented <a href="https://cmannett85.github.io/arg_router/configuration.html">here</a>.</p>
<h1>Supported Compilers/Platforms</h1>
<p>The CI system attached to this repo builds the unit tests and examples with:</p><ul>
<li>Ubuntu 22.04 (Ninja), Clang 14, gcc-12, gcc-9, gcc-9 32bit</li>
<li>Windows Server 2022 (Ninja, MSBuild), Clang 14.0.5, MSVC 19.34(C++20 only)</li>
<li>MacOS 12 (Ninja), Clang 14</li>
</ul>
<p>You can build on Windows with using MSBuild but you must set the CMake variable <code>DEATH_TEST_PARALLEL</code> to 1 otherwise the parallel tests will attempt to write to the project-wide <code>lastSuccessfulBuild</code> file simultaneously, which causes the build to fail. MSVC is supported but only when using the C++20-style compile-time strings due <a href="https://developercommunity.visualstudio.com/t/1395099">this</a> MSVC bug.</p>
<p>Other compiler versions and platform combinations may work, but I'm currently limited by the built-in GitHub runners and how much I'm willing to spend on Actions!</p>
<h1>Tips for Users</h1>
<h2>Do <b>NOT</b> Make the Parse Tree Type Accessible</h2>
<p>The parse tree is <em>very</em> expensive to construct due to all the compile-time checking and meta-programming shennanigans, so do <b>NOT</b> define it in a header and have multiple source files include it - it will cause the tree to be built/checked in every source file it is included in.</p>
<h2>Minimise Static Storage Bloat</h2>
<p>Despite not using <code>typeid</code> or <code>dynamic_cast</code> in the library, compilers will still generate class name data if RTTI is enabled, because it is used in the standard library implementations (e.g. <code>std::function</code> on Clang). Due to the highly nested templates that make up the parse tree, these class names can become huge and occupy large amount of static storage in the executable. As an example, the <code>basic_cat</code> project in the repo will create ~100KB of class name data in the binary - this data is not used and cannot be stripped out.</p>
<p>Disabling RTTI is rarely feasible for most projects, but it is possible to disable RTTI for a single CMake target. So if it was deemed worth it for the size reduction, the command line parsing could be the application's executable (compiled without RTTI) and then the wider application logic could be in a static library (compiled with RTTI). This does not affect exceptions, as their type information is always added by the compiler regardless of RTTI status.</p>
<h2>Newer Compilers are Better with Templates</h2>
<p>This may seem like an obvious point, but people need reminding: The rise of TMP use has been quicker than the compiler optimisations for it. In practice this means that although <code><a class="el" href="namespacearg__router.html">arg_router</a></code> can be compiled on e.g. GCC v9, it will use staggeringly more memory than e.g. GCC v11.</p>
<h1>Extra Documentation</h1>
<p>Complete Doxygen-generated API documentation is available <a href="https://cmannett85.github.io/arg_router/">here</a>. Examples are provided in the <code>examples</code> directory of the repo or online <a href="https://cmannett85.github.io/arg_router/examples.html">here</a>. Doxygen theming is provided by <a href="https://github.com/jothepro/doxygen-awesome-css">Doxygen Awesome CSS</a>.</p>
<p>The latest unit test coverage report is found <a href="https://cmannett85.github.io/arg_router/gcov_html/">here</a>.</p>
<h1>Future Work</h1>
<p>Take a look at the <a href="https://github.com/cmannett85/arg_router/issues">issues</a> page for all upcoming features and fixes. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
